<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="xmlspec/diffspec_my.xsl"?>
<!--<?xml-stylesheet type="text/xsl" href="xmlspec/diffspec.xsl"?>-->
<spec xmlns:xlink="http://www.w3.org/1999/xlink" 
	xmlns:xi="http://www.w3.org/2001/XInclude" w3c-doctype="pr" status="int-review">


  <!-- 
       -
       -       SCXML Spec Header 
       -
  -->

  <header>
    <title>State Chart XML (SCXML): State Machine Notation for Control Abstraction</title>
    
    <w3c-designation>SCXML-20140529</w3c-designation>
    <w3c-doctype>W3C Proposed Recommendation</w3c-doctype>


    <pubdate><day>@@</day><month>@@</month><year>2014</year></pubdate>


    <publoc>
      <loc href="http://www.w3.org/TR/2014/WD-scxml-20140529/"/>
    </publoc>
    <latestloc>
      <loc href="http://www.w3.org/TR/scxml/"/>
    </latestloc>
    <prevlocs>
      <loc href="http://www.w3.org/TR/2014/CR-scxml-20140313/"/>
    </prevlocs>
<authlist>
      <author>
        <name>Jim Barnett</name>
        <affiliation>Genesys (Editor-in-Chief)</affiliation>
        </author>
     <author>
       <name>Rahul Akolkar</name>
       <affiliation>IBM</affiliation>
       </author>
     <author>
       <name>RJ Auburn</name>
     <affiliation>Voxeo </affiliation>
     </author>
     <author>
        <name>Michael Bodell</name>
        <affiliation>(until 2012, when at Microsoft)</affiliation>
      </author>
    <author>
    <name>Daniel C. Burnett</name>
     <affiliation>Voxeo </affiliation>
     </author>
    <author>
    <name>Jerry Carter</name>
     <affiliation>(until 2008, when at Nuance) </affiliation>
     </author>
      <author>
        <name>Scott McGlashan</name>
        <affiliation>(until 2011, when at HP)</affiliation>
       </author>

      <author>
        <name>Torbj&#246;rn Lager</name>
        <affiliation>Invited Expert</affiliation>
      </author>
    <author>
        <name>Mark Helbing</name>
        <affiliation>(until 2006, when at Nuance)</affiliation>
      </author>
      <author>
        <name>Rafah Hosn</name>
        <affiliation>(until 2008, when at IBM)</affiliation>
      </author>
     <author>
     <name>T.V. Raman</name>
     <affiliation>(until 2005, when at IBM)</affiliation>
     </author>
          <author>
     <name>Klaus Reifenrath</name>
     <affiliation>(until 2006, when at Nuance)</affiliation>
     </author>
     <author>
     	<name>No'am Rosenthal</name>
     	<affiliation>(until 2009, when at Nokia)</affiliation>
     	</author>
       <author>
     	<name>Johan Roxendal</name>
     	<affiliation>Invited Expert</affiliation>
     	</author>
</authlist>   

<p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2015 <a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="http://www.ercim.eu/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p><hr/>



    <status>
<p><emph>This section describes the status of this document at the time of its
publication. Other documents may supersede this document. A list of current
W3C publications and the latest revision of this technical report can be
found in the <loc xmlns:xlink="http://www.w3.org/1999/xlink" 
	href="http://www.w3.org/TR/" xlink:type="simple" xlink:show="replace" 
	xlink:actuate="onRequest">W3C technical reports index</loc> at http://www.w3.org/TR/.</emph></p>

<p>This is the @@@ W3C Proposed Recommendation of SCXML Version 1.0.   W3C publishes a technical report as a Proposed Recommendation to indicate that the document is a mature technical report that has received wide review for technical soundness and implementability and to request final endorsement 
	from the W3C Advisory Committee. Proposed Recommendation status is described in section 7.1.1 of the
	<a href="http://www.w3.org/2004/02/Process-20040205/tr.html#maturity-levels">Process Document</a>.
	</p>
	
	<p>The W3C Membership and other interested parties are invited to review the document and send comments to 
		the Working Group's public mailing list <a href="mailto:www-voice@w3.org">www-voice@w3c.org</a>(<a href="http://lists.w3.org/Archives/Public/www-voice/">archive</a>) until @@@. 
		See <a href="http://www.w3.org/Mail/">W3C Mailing List and Archive Usage Guidelines</a>. 
		Advisory Committee Representatives should consult <a href="http://www.w3.org/2002/09/wbs/myQuestionnaires">
			their WBS questionnaires</a>. </p>
			
			<p>This document is based upon the <a href="http://www.w3.org/TR/2014/CR-scxml-20140313/">
				State Chart XML (SCXML) Candidate Recommendation</a> of 13 March 2014, 
				the subsequent third <a href="http://www.w3.org/TR/2014/WD-scxml-20140529/"> Last Call Working Draft
					</a> version of 29 May 2014, and feedback received during the review period 
					(see the <a href="@@@">Disposition of Comments - UPDATE LINK
						</a> document). The substantive changes from 29 May 2014 
					Last Call Working Draft consist in the removal of the XPath Datamodel and the DOM Event I/O Processor, 
					both of which were listed as features at risk in the 13 March 2014 Candidate Recommendation.</p>
	
<p>	 The 
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Voice/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Voice Browser Working Group</loc>
(<a href="http://www.w3.org/Help/Account/">(W3C Members only)</a>
 believes that this specification addresses its requirements and all Last Call and Candidate Recommendation issues. 
 Known implementations are documented in the <a href="@@@">
 	SCXML 1.0 Implementation Report - UPDATE LINK</a>, along with the associated test suite.</p>
 
 <p>This document has been produced as part of the <a href="http://www.w3.org/Voice/"> Voice Browser Activity</a> 
 	<a href="http://www.w3.org/Voice/Activity">(activity statement)</a>, following the procedures set out for 
 	the <a href="http://www.w3.org/Consortium/Process/">W3C Process</a>. 
 	The authors of this document are members of the <a href="http://www.w3.org/Voice/">Voice Browser Working Group</a>.</p>



<p> This document was produced by a group operating under the 
	<a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 W3C Patent Policy</a>. 
	 The group does not expect this document to become a W3C Recommendation. 
W3C maintains a <a rel="disclosure" href="http://www.w3.org/2004/01/pp-impl/34665/status">public list of any patent disclosures</a> 
made in connection with the deliverables of the group; that page also 
includes instructions for disclosing a patent. An individual who 
has actual knowledge of a patent which the individual believes contains 
<a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential 
	Claim(s)</a> must disclose the information in 
	accordance with 
	<a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section 6 of the W3C 
		Patent Policy</a>. </p>
<p>Publication as a Proposed Recommendation does not imply endorsement by the W3C Membership. This is a draft document and may be updated, replaced or obsoleted by other documents at any time. It is inappropriate to cite this document as other than work in progress.</p>

<p>The sections of this document are normative unless otherwise specified. </p>

</status>
    
    <abstract>
      <p>This document describes SCXML, or the "State Chart extensible Markup Language". 
      SCXML provides a generic state-machine based execution environment based on CCXML and Harel State Tables.</p>
    </abstract>
    
    <langusage>
      <language id="EN">English</language>
    </langusage>
    <revisiondesc>
      <slist>
        <sitem>February 16, 2005: Initial W3C CVS Checkin.</sitem>
        <sitem>February 15, 2005: First XMLSpec version.</sitem>
        <sitem>July 5, 2005: First public draft.</sitem>
        <sitem>January 20, 2006: Second public draft.</sitem>
      </slist>
    </revisiondesc>
  </header>

  <!-- 
       -
       -	SCXML Main Content 
       -
  -->

  <body>
    <div1 id="terminology">
      <head>Terminology</head>
      
      <p>The key words 
     <rfc2119>must</rfc2119>, <rfc2119>must not</rfc2119>, <rfc2119>required</rfc2119>,
     <rfc2119>shall</rfc2119>, <rfc2119>shall not</rfc2119>, <rfc2119>should</rfc2119>, 
     <rfc2119>should not</rfc2119>, <rfc2119>recommended</rfc2119>, <rfc2119>may</rfc2119>, 
      and <rfc2119>optional</rfc2119> in this specification are to be interpreted 
      as described in <bibref ref="RFC2119"/>.</p>
      
      
      <p>The terms base URI and relative URI 
      are used in this specification as they are defined in <bibref ref="RFC2396"/>.</p>
      
      <p>All sections not marked as "informative" are normative.</p>
    </div1>

    <div1 id="overview">
      <head>Overview</head>  
 <p>[This section is  informative.]</p>
 <p>This document outlines State Chart XML (SCXML), which is a general-purpose event-based 
 state machine language that combines concepts from CCXML and Harel State Tables. 
  CCXML <bibref ref="CCXML"/> is an event-based state machine language
      designed to support call control features in Voice Applications
      (specifically including VoiceXML but not 
      limited to it). The CCXML 1.0
      specification defines both a state machine and event handing 
      syntax and a
      standardized set of call control elements. Harel State Tables are a state
      machine notation that was developed by the mathematician David Harel
      <bibref ref="Harel_Politi"/> and is included in 
      UML <bibref ref="UML"/>. They offer a
      clean and well-thought out semantics for sophisticated constructs
      such as parallel states.  They have been defined as a graphical specification
      language, however, and hence
      do not have an XML representation.  The goal of
      this document is to combine Harel semantics with an XML syntax
      that is a
      logical extension of CCXML's state and event notation.  </p>
      
      <p><specref ref="Basic"/> presents the core state machine concepts, while
      	<specref ref="executable"/> contains an extensible set of actions that the state machine
      	can take in response to events.  <specref ref="data-module"/>  
      	defines constructs for storing and modifying data, while <specref ref="external-module"/>
      	provides the capability of communicating with external entities. 
      	</p>

       
    </div1>

    
    
    <div1 id="Basic">
      <head>Core Constructs</head>
      <div2 id="CoreIntroduction">
      	<head>Introduction</head>
<p>[This section is informative.]</p>
      	<div3 id="BasicState">
      		<head>Basic State Machine Notation</head>
<p>The most basic state machine concepts are <specref ref="state"/>, <specref ref="transition"/>
	and event (<specref ref="events"/>). Each state contains a set of transitions that
	define how it reacts to events.   Events can be generated by the state machine itself or
	by external entities.  In a traditional state machine, the machine is always in a single state.
	This state is called the active state.  
	When an event occurs, the state machine checks the transitions that are defined in the active state.
	If it finds one that matches the event, it moves from the active state to the state specified
	by the transition (called the "target" of the transition.)  Thus the target state becomes the new
	active state. 
</p> 
<p>The Harel state notation defines several extensions to these basic notions.  First of all,
	the state machine may take actions (as defined in <specref ref="executable"/>) while taking
	transitions.  Specifically, each state may contain <specref ref="onentry"/> and <specref ref="onexit"/>
	actions.  Transitions may also contain actions.  If a state machine takes transition T from
	state S1 to state S2, it first performs the onexit actions in S1, then the actions in T,
	then the onentry actions in S2.  Secondly, in addition to the 'event' attribute that specifies
	the event(s) that can trigger it, transitions also have a 'cond' attribute.  If a transition has 
	both 'event' and 'cond' attributes, it
        will be selected only if an event is raised whose name matches the 'event' attribute 
        (see <specref ref="EventDescriptors"/> for details)  and the
        'cond' condition evaluates to true.   
        If the 'event' attribute is missing,  the transition is taken whenever the 'cond' evaluates to true. 
        If more than one 
         	transition matches, the first one in document order will be taken.
         	Thus, in the following
         example, the system will transition to s1 when event e (or e.foo, etc.) occurs if x is equal to 1, but will
         transition to s2 if event e (or e.foo, etc.) occurs and x is not equal to 1, and will go to s3 if 
         any other event
         occurs. 
         </p> 
         <eg xml:space="preserve"><xi:include href="SCXMLExamples/transitionOrderExample.scxml" parse="text"/></eg>         

         </div3>
         <div3>
         	<head>Compound States</head>
         <p>One of the most powerful concepts in Harel notation is the idea that states may
         	have internal structure.  In particular, a &lt;state&gt; element may contain nested
         	&lt;state&gt; elements.  Such a state is called a compound state and we speak of it
         	as the parent state, while the nested elements are child states.  The child states may
         	themselves have nested children and the nesting may proceed to any depth.  Ultimately
         	we will reach a state
         	that does not contain any child states.  Such a state is called an atomic state. 
         	When a compound state is active, one and only one of its child states is active. Conversely,
         	when an child state is active, its parent state must be active too.  Thus at any point
         	we have a set of active states, containing an atomic state and all of its ancestors.  (We
         	will see in the next section that multiple atomic states can be active at the same time.)
         	 
         	</p>
         	
         	<p>Compound states also affect how transitions are selected.  
	         	When looking for transitions, the state machine first looks in the most deeply nested 
         	active state(s), i.e., in the atomic state(s) that have no substates.  If no transitions
         	match in the atomic state, the state machine will look in its parent state, then in the
         	parent's parent, etc.  Thus transitions in ancestor states serve as defaults that will
         	be taken if no transition matches in a descendant state.  If no transition
         	matches in any state, the event is discarded.  
         		</p> 
  
        </div3>
        <div3>
        	<head>Parallel States</head>
        	        <p>
          The &lt;parallel&gt; element represents a state whose children execute in parallel. 
          Like &lt;state&gt;, the &lt;parallel&gt; element contains &lt;onentry&gt;,
          &lt;onexit&gt;, &lt;transition&gt;, and &lt;state&gt; or &lt;parallel&gt; children. 
          However, the semantics of &lt;parallel&gt; are different.  When
          a &lt;state&gt; is active, exactly one of its children is active.  When a &lt;parallel&gt;
          element is active, <em>all</em> of its children are active.  Specifically, when the state
        machine enters the parent &lt;parallel&gt; state, it also enters each child state.  The child
        states execute in parallel in the sense that any event that is processed
          is processed in each child state independently, and 
          each child state may take a different transition in response to the event. (Similarly,
          one child state may take a transition in response to an event, while another child ignores it.) 
          When all of the children reach final
          states, the &lt;parallel&gt; element itself is considered to be in a final state, and a completion 
          event done.state.<em>id</em> is generated, where <em>id</em> is the id of
          the &lt;parallel&gt; element.  </p>
        <p>
        Transitions <emph>within</emph> the individual child elements operate normally.  
        However whenever a transition is taken with a target <emph>outside</emph> the 
        &lt;parallel&gt; element, the &lt;parallel&gt; element and all of its 
        child elements are exited and the corresponding &lt;onexit&gt; handlers are executed.  The
        handlers for the child elements execute first, 
        in document order, followed by those of the 
        parent &lt;parallel&gt; element, followed by an action expression in the &lt;transition&gt; 
        element, and then the &lt;onentry&gt; handlers in the "target" state. </p>
              	<p>In the following example, parallel state 'p' has two children S1 and S2.  Suppose a transition
      		takes S1's child S12 as a target. (Note that this is permitted even though S12 is not the default initial
      		state for S1 and that S11 is not, in fact, visited in the course of this example). 
      		Upon this transition, the state machine, in addition to entering S1 and S12, 
      		will also enter S1's parallel sibling S2 and its initial state S21.  Once the transition
      		has been taken, p, S1, S2, S12, and S21 will all be active.  If event 'e1' occurs, it will 
      		cause S12 to transition to S1Final, and S21 to transition to S22.  Entering S1Final will
      		 cause the event done.state.S1 to be generated.  At this point, S1 is in a final state, but
      		 S2 is still active.  Now suppose event 'e2' occurs.  This will cause S22 to transition to
      		 S2Final, and the event done.state.S2 will be generated.  Furthermore, since all of p's
      		 children are now in final states, the event 'done.state.p' will be generated, which will
      		  cause the transition contained in p to be triggered, exiting the entire region.</p>
      		           <eg xml:space="preserve"><xi:include href="SCXMLExamples/parallelExample.scxml" parse="text"/></eg>
        
        <p> Note that the semantics of the  &lt;parallel&gt; element does not call for multiple threads or
        	 truly concurrent processing.  The children of &lt;parallel&gt; execute in parallel in
        	 the sense that they are all simultaneously active and each one independently selects transitions for
        	 any event that is received.  However, the
        	  parallel children process the event in a defined, serial order, so no conflicts
        	  or race conditions
        	  can occur.  See <specref ref="AlgorithmforSCXMLInterpretation"/>
        for a detailed description of the semantics of &lt;parallel&gt; and the rest of SCXML. </p>
        	</div3>
        	
        	    <div3>
       
      	<head>Initial, Final, and History States</head>
         	<p>In the presence of compound states, transitions no longer simply move from the
         		current active state to a new active state, but from one set of active states to another.
         		(See <specref ref="LegalStateConfigurations"/> for details.)  If the target of a transition
         		is an atomic state, the state machine will enter not only the atomic state, but also
         		any of its ancestor states that are not already active. Conversely, a transition may
         		take a compound state as its target.  In this case, one of the compound state's children
         		must also become active, but the transition does not specify which one.   In this case
         		we look at the target state's <specref ref="initial"/> child
         		which specifies the state's default initial state, that is, the child state to enter if
         		the transition does not specify one. (If the default initial state is itself compound,
         		the state machine will also enter its default initial state, and so on recursively until
         		it reaches an atomic state.)  The presence of default initial states provides a form
         		of encapsulation, since a transition may select a compound state as its target without
         		understanding its internal substate structure.   
         		</p>
         		     <p>The default initial state of a compound state may also be specified
         		     	via the 'initial' attribute.  The only difference between the &lt;initial&gt; element and the 'initial' attribute
      is that the &lt;initial&gt;
      element contains a &lt;transition&gt; element which may in turn contain 
      executable content which will
      be executed before the default state is entered.  If the 'initial' attribute 
      is specified instead, the 
      specified state will be entered, but no executable content will be executed.   
      (If neither the &lt;initial&gt; child or the 'initial' element is 
      specified, the default initial state is the first child state in document order.)
      As an example,
      suppose that parent state S contains child states S1 and S2 in that order.  If S specifies 
      S1 as its default
      initial state via the 'initial' attribute (or fails to specify any initial state), then any transition that 
      specifies S as its target will
      result in the state machine entering S1 as well as S.  In this case, the result is 
      exactly the same as if the transition
      had taken S1 as its target.  If, on the other hand, S specifies S1 as 
      its default initial state
      via an &lt;initial&gt; element containing a &lt;transition&gt; with S1 as 
      its target, the &lt;transition&gt;
      can contain executable content which will execute before the default entry into S1.  In this case,
      there is a difference between a transition that takes S as its target 
      and one that takes S1 as its
      target.  In the former case, but not in the latter, the executable content 
      inside the &lt;initial&gt;
      transition will be executed.</p>
         		<p>A compound state may also have final and history states as
         			children.  <specref ref="final"/> is used to signify that the 
         			parent state is in some sense "done" with its processing.  When a state machine
         			enters a &lt;final&gt; substate of a compound state, the parent state remains active, but
         			the event "done.state.<em>id</em>" is generated, where <em>id</em> is the state
         			id of the parent state.  This event can trigger a transition in any ancestor
         			state (including the parent).  If the transition takes a target outside the 
         			parent state, the "done.state.<em>id</em>" event in effect serves as a signal that it is time to
         			leave the parent state.  <specref ref="history"/> allows for pause and resume semantics
         			in compound states.  Before the state machine exits a compound state, it records the 
         			state's active descendants.  If the 'type' attribute of the 
         			&lt;history&gt; state is set to "deep", the state machine
         			saves the state's full active descendant configuration, down to the atomic descendant(s).  
         			If 'type'
         			is set to "shallow", the state machine remembers only which immediate child was active.
         			After that, if a transition takes a &lt;history&gt;
         			child of the state as its target, the state machine re-enters not only the 
         			parent compound state but also the state(s) in the saved configuration. Thus a transition
         			with a deep history state as its target returns to exactly where the state was when it
         			was last exited, while a transition with a shallow history state as a target re-enters
         			the previously active child state, but will enter the child's default initial state (if
         			the child  is itself compound.)
         			
         			</p>
         			</div3>
         <div3>
         	<head>'Type' and Transitions </head>   
                  <p> In the case of a transition located in a compound state, the
                  	'type' attribute is significant. The behavior of a transition with 'type' of "external" 
                  	(the default) is defined in terms of 
          the transition's source state (which is the state that contains the transition), the
          transition's target state(or states), and the <a href="#LCCA">Least Common Compound Ancestor (LCCA)</a>
          of the source and target states (which is the closest compound state that is an ancestor of all
          the source and target states).  When a transition
          is taken, the state machine will exit all active states that are proper descendants of the LCCA, starting
          with the innermost one(s) and working up to the immediate descendant(s) of the LCCA.  (A 'proper descendant'
          of a state is a child, or a child of a child, or a child of a child of a child, etc.) Then
          the state machine enters the target state(s), plus any states that are between it and the LCCA,
           starting with the outermost one (i.e., the immediate descendant of the LCCA) and working
           down to the target state(s).  As states are exited, their &lt;onexit&gt; handlers are executed.
           Then the executable content in the transition is executed, followed by the &lt;onentry&gt; 
           handlers of the states that are entered.  If the target state(s) of the transition is not
           atomic, the state machine will enter their default initial states recursively until it reaches
           an atomic state(s). 
           </p>
           
          <p> In the example below, assume that state s11 is active
           when event 'e' occurs.  The source of the transition is state s1, its target is state
           s21, and the LCCA is state S.  When the transition is taken, first state S11 is exited,
           then state s1, then state s2 is entered, then state s21.   Note that the LCCA S is neither
           entered nor exited.  For more details see <specref ref="SelectingTransitions"/> and <specref ref="AlgorithmforSCXMLInterpretation"/>.         
           </p>
         <eg xml:space="preserve"><xi:include href="SCXMLExamples/transitionExample.scxml" parse="text"/></eg>         
          <p>The behavior of transitions with 'type' of "internal" is identical, except in the case of
          	a transition whose source state is a compound state and whose target(s) is a descendant of the
          	source.  In such a case, an internal transition will not exit and re-enter its source
          	state, while an external one will, as shown in the example below.
          	</p>
          	         <eg xml:space="preserve"><xi:include href="SCXMLExamples/transitionExample2.scxml" parse="text"/></eg>         
          <p>If the 'target' on a &lt;transition&gt; is omitted, then the value of 'type' does not
          	have any effect and taking
          the transition does not change the state configuration but does invoke the 
          executable content that is included in the transition.  Note that this is different from a &lt;transition&gt;
          whose 'target' is its source state.  In the latter case, the state is exited and reentered,
        triggering execution of its &lt;onentry&gt; and &lt;onexit&gt; executable content. </p>

         </div3>
</div2>
      <div2 id="scxml">
        <head>&lt;scxml&gt;</head>
         <p>[This section is  normative.]</p>		
        <p>The top-level wrapper element, which carries version information.  The actual state
        	machine consists of its children.  Note that only one of the children
        	 is active at any one time.  See 	<specref ref="LegalStateConfigurations"/> for details.  </p>
               
       <div3 id="scxml-attr">
          <head>Attribute Details</head>
                 <xi:include href="attributes/scxml.xml.html"/>
        </div3>
        
      <div3>
          <head>Children</head>
          <ulist>
            <item><p>&lt;state&gt; A compound or atomic  state.  
            Occurs zero or more times.  See <specref ref="state"/> for details. </p></item>

            <item><p>&lt;parallel&gt; A parallel state.  
            Occurs zero or more times.  See <specref ref="parallel"/> for details. </p></item>
           <item><p>&lt;final&gt; A top-level final state in the state machine.  
            Occurs zero or more times.  The SCXML processor <rfc2119>must</rfc2119> terminate
            processing when the state machine reaches this
            state.  See <specref ref="final"/> for details. </p></item>
  
       <item><p> &lt;datamodel&gt; Defines part or all of the data model.  Occurs 0 or 1 times.
            See <specref ref="datamodel"/></p></item> 
             <item><p> &lt;script&gt; Provides scripting capability.  Occurs 0 or 1 times.
             <specref ref="script"/></p></item> 
             </ulist>
      	</div3>
      	<p>A conformant SCXML document <rfc2119>must</rfc2119> have at least one
      	&lt;state&gt;, &lt;parallel&gt; or &lt;final&gt; child. At system initialization time, the SCXML Processor
      	<rfc2119>must</rfc2119> enter the states specified by the 'initial' attribute, if it is present. If
      	it is not present, the Processor <rfc2119>must</rfc2119> enter the first state in document order.  Platforms <rfc2119>should</rfc2119> document their
      	default data model.</p>
      </div2>

      <div2 id="state">
        <head>&lt;state&gt;</head>	
                 <p>[This section is  normative.]</p>			
        <p>Holds the representation of a state.</p>
               
        <div3>
         <head>Attribute Details</head>
          <xi:include href="attributes/state.xml.html"/>
          
        </div3>
          
        <div3>
          <head>Children</head>
          <ulist>
 
            <item><p>&lt;onentry&gt; Optional element holding executable content to be
            run upon entering this &lt;state&gt;. Occurs 0 or more times. 
             See <specref ref="onentry"/></p></item>

            <item><p>&lt;onexit&gt; Optional element holding executable content
            to be run when exiting this &lt;state&gt;. Occurs 0 or more times.  See
            <specref ref="onexit"/> </p></item>

            <item><p>&lt;transition&gt; Defines an outgoing transition from this
            state. Occurs 0 or more times. See <specref ref="transition"/></p></item>
            
            <item><p>&lt;initial&gt; In states that have substates, an optional child which identifies the default initial state. 
             Any transition which takes the
            parent state as its target will result in the state machine also taking the transition contained
           inside the &lt;initial&gt; element. See <specref ref="initial"/> </p></item>
            

            <item><p>&lt;state&gt; Defines a sequential substate of the parent state.  Occurs 0 or more times.
            </p></item>
            
            <item><p> &lt;parallel&gt; Defines a parallel substate.  Occurs 0 or more times. 
            See <specref ref="parallel"/></p></item> 

            <item><p> &lt;final&gt;.  Defines a final substate.  Occurs 0 or more
            times.  See <specref ref="final"/>.</p></item>
           
            <item><p>&lt;history&gt; A child pseudo-state which records the descendant state(s) that
            the parent state was in the last time the system transitioned <emph>from</emph> the parent.  
            May occur 0 or more times.  See <specref ref="history"/>. 
            </p></item>
 
       <item><p> &lt;datamodel&gt; Defines part or all of the data model.  Occurs 0 or 1 times.
            See <specref ref="datamodel"/></p></item> 
       <item><p> &lt;invoke&gt; Invokes an external service.  Occurs 0 or more times. 
       See <specref ref="invoke"/> for details.
           </p></item> 
               </ulist>
      	</div3>
      	<p><termdef id="atomic-state" name="atomicState">An <term>atomic state</term> is a &lt;state&gt; that has no &lt;state&gt;, 
      	&lt;parallel&gt; or &lt;final&gt; children.</termdef> </p>
      	<p><termdef id="compound-state" name="compoundState">A <term>compound state</term> is a &lt;state&gt; that has &lt;state&gt;,
      	&lt;parallel&gt;, or &lt;final&gt; children (or a combination of these).</termdef></p>
      	<p><termdef id="default-initial-state" name="defaultInitialState">The <term>default initial state(s)</term>
      	of a compound state are those specified by the 'initial' attribute or &lt;initial&gt; element, if
      	either is present. Otherwise it is the state's first child state in document order. </termdef></p>
 <p>In a conformant SCXML document, a compound state
      <rfc2119>may</rfc2119> specify either an "initial" attribute or an &lt;initial&gt;
      element, but not both.  See <specref ref="initial"/> for a discussion of the difference between the two notations. 
    
      
      </p> 
     </div2>




            <div2 id="parallel">
        <head>&lt;parallel&gt;</head>	
                 <p>[This section is  normative.]</p>			
        <p>
          The &lt;parallel&gt; element encapsulates a set of child states which are
          simultaneously active when the parent element is active.
          </p>
        
      <div3>
          <head>Attribute Details</head>
          <xi:include href="attributes/parallel.xml.html"/>

          </div3>
          
       <div3>
       <head>Children</head>
          <ulist>
            <item><p>&lt;onentry&gt; Holds  executable content to be
            run upon entering the &lt;parallel&gt; element. Occurs 0 or more times. 
             
             See <specref ref="onentry"/></p></item>

            <item><p>&lt;onexit&gt; Holds executable content
            to be run when exiting this element. Occurs 0 or more times. 
             See
            <specref ref="onexit"/> </p></item>
            
            <item><p>&lt;transition&gt; Defines an outgoing transition from this
            state. Occurs 0 or more times. See <specref ref="transition"/></p></item>

            <item><p>&lt;state&gt; Defines a parallel substate region. Occurs 0 or more times.  See <specref ref="state"/>.</p></item>
            
            <item><p>&lt;parallel&gt; Defines a nested set of parallel regions.  Occurs
            0 or more times.</p></item>
          <item><p>&lt;history&gt; A child which represents the state configuration that
            this state was in the last time the system transitioned <emph>from</emph> it.  
            A transition with this history pseudo-state as its target is in fact a transition to the set of descendant states
            that were active the last time this state was exited.  Occurs 0 or more times.  See <specref ref="history"/>. 
            </p></item>
       <item><p> &lt;datamodel&gt; Defines part or all of the data model.  Occurs 0 or 1 times. 
            See <specref ref="datamodel"/></p></item> 
       <item><p> &lt;invoke&gt; Invokes an external service.  Occurs 0 or more times. See <specref ref="invoke"/>
       for details.
           </p></item> 
            </ulist>
      	</div3>

       </div2>
      <div2 id="transition">
        <head>&lt;transition&gt;</head>	
                 <p>[This section is  normative.]</p>			
        <p>
          Transitions between states are triggered by events and conditionalized
          via guard conditions. They may contain executable content, which 
          is executed when the transition is taken.    

          </p>
   

               <div3>
          <head>Attribute Details</head>
          <xi:include href="attributes/transition.xml.html"/>
          </div3>
          
          
            <div3>
          <head>Children</head>
          <ulist>

            <item><p> The children of &lt;transition&gt; are
            executable content that is run after all the &lt;onexit&gt; 
            handlers and before the all &lt;onentry&gt; handlers that are triggered
            by this transition.  See
            <specref ref="executable"/>
            </p></item>
            </ulist>
   
            </div3>
            <p>A conformant SCXML document <rfc2119>must</rfc2119> specify at least one of 'event', 'cond' or 'target'. <specref ref="SelectingTransitions"/> contains more detail on the semantics of
            transitions.</p>
            
  
     
      </div2>
             <div2 id="initial">
        <head>&lt;initial&gt;</head>
                 <p>[This section is  normative.]</p>		
        <p> This element represents the default initial state for a complex &lt;state&gt; element (i.e.	one containing child &lt;state&gt; or &lt;parallel&gt; elements.  </p>
 
       
        
      <div3>
          <head>Attribute Details</head>
          <p>None</p>
          </div3>
          
      <div3>
          <head>Children</head>
          <ulist>
           <item><p>&lt;transition&gt;  A transition whose 'target' specifies the default
           initial state(s).  Occurs once.  In a conformant SCXML document, this transition <rfc2119>must not</rfc2119> contain 'cond' or
           'event' attributes, and <rfc2119>must</rfc2119> specify a non-null 'target' whose value
           is a valid state specification consisting solely of descendants of the containing state (see <specref ref="LegalStateConfigurations"/> for details).
           This transition <rfc2119>may</rfc2119> contain executable content.            
            </p></item>
          </ulist>
        </div3>
      </div2>
        <div2 id="final">
        <head>&lt;final&gt;</head>
                 <p>[This section is  normative.]</p>		
        <p>&lt;final&gt; represents a final state of an &lt;scxml&gt; or compound &lt;state&gt;
        	element.   </p>
        
        <div3>
        <head>Attribute Details</head>
                  <xi:include href="attributes/final.xml.html"/>
        </div3>
        <div3>
        <head>Children</head>
        <ulist>
         <item><p>&lt;onentry&gt; Optional element holding executable content to be
            run upon entering this state. Occurs 0 or more times. 
             See <specref ref="onentry"/> for details.</p></item>

            <item><p>&lt;onexit&gt; Optional element holding executable content
            to be run when exiting this state. Occurs 0 or more times.  See
            <specref ref="onexit"/> for details. </p></item>
            <item><p>&lt;donedata&gt;  
            Optional element specifying data to be included in
            the done.state.<em>id</em> or done.invoke.<em>id</em> event.  See <specref ref="donedata"/> for details.  
            </p></item>
         </ulist>
         
        </div3>
        
    <p>  When the state machine enters the &lt;final&gt; child of a &lt;state&gt; element, 
        the SCXML Processor <rfc2119>must</rfc2119> generate the event done.state.<em>id</em>
        after completion of the &lt;onentry&gt; elements, where  
        <em>id</em> is
        the id of the parent state.  Immediately thereafter, if the parent &lt;state&gt;
         is a child of a &lt;parallel&gt;
        element, and all of the &lt;parallel&gt;'s  other children are also in final states, the
        Processor <rfc2119>must</rfc2119> generate the event done.state.<em>id</em> where
        <em>id</em> is the id of the &lt;parallel&gt; element. </p> 
        
        <p>When the state machine reaches the &lt;final&gt; child of an &lt;scxml&gt; 
        element, it <rfc2119>must</rfc2119> 
        terminate.  See <specref ref="AlgorithmforSCXMLInterpretation"/> for details.   
        If the SCXML session was triggered
        as the result by an &lt;invoke&gt; element in another session, the SCXML processor
        <rfc2119>must</rfc2119> generate the event
        done.invoke.<em>id</em> after termination and return it to the other session, 
        where <em>id</em> is the unique identifier generated when the &lt;invoke&gt; 
        element was executed.  See <specref ref="invoke"/> for details.  </p>
        </div2>
        

        <div2 id="onentry">
        <head>&lt;onentry&gt;</head>
                 <p>[This section is  normative.]</p>		
        <p>A wrapper element containing executable content to be executed when the state is entered.</p>
          <div3>
        <head>Attribute Details</head>
        <p>None.</p>
        </div3>
        <div3>
          <head>Children</head>
          <p>The children of the &lt;onentry&gt; handler consist of executable
          content as defined in <specref ref="executable"/>.   </p>
          </div3>
          <p>The SCXML processor  <rfc2119>must</rfc2119>
          execute the &lt;onentry&gt; handlers of a state
          in document order when the state
          is entered.  In doing so, it <rfc2119>must</rfc2119> treat each handler as a separate
          block of executable content. 
          </p>
          </div2>
       
       <div2 id="onexit">
       	        <head>&lt;onexit&gt;</head>
       	                 <p>[This section is  normative.]</p>		
       	        <p>A wrapper element containing executable content to be executed when the 
       	        	state is exited.</p>

        <div3>
        <head>Attribute Details</head>
        <p>None.</p>
        </div3>
        <div3>
          <head>Children</head>
          <p>The children of the &lt;onexit&gt; handler consist of executable
          content as defined in <specref ref="executable"/>. </p>
          </div3>
 <p>The SCXML processor  <rfc2119>must</rfc2119>
          execute the &lt;onexit&gt; handlers of a state
          in document order when the state
          is exited.  In doing so, it <rfc2119>must</rfc2119> treat each handler as a separate
          block of executable content.  
          </p>
          </div2>



      <div2 id="history"> <head>&lt;history&gt;</head> <p>The &lt;history&gt; 
      pseudo-state allows a state machine to remember its state configuration.  A 
      &lt;transition&gt; taking the &lt;history&gt; state as its target will 
      return the state machine to this recorded configuration. </p> 
      
     

        <div3>
          <head> Attribute Details</head>
          <xi:include href="attributes/history.xml.html"/>
           </div3>
           
          <div3>
          <head>Children</head>
          <ulist>
            <item><p>&lt;transition&gt;  A transition whose 'target' 
            specifies the default history configuration. Occurs once.
            In a conformant SCXML document, this transition 
           <rfc2119>must not</rfc2119> contain 'cond' or
           'event' attributes, and <rfc2119>must</rfc2119> specify a non-null 'target' whose value
           is a valid state specification (see <specref ref="LegalStateConfigurations"/>).
           This transition <rfc2119>may</rfc2119> contain executable content.  
            If 'type' is "shallow", then the 'target' of this &lt;transition&gt; <rfc2119>must</rfc2119> 
            contain only immediate children
            of the parent state.  Otherwise it <rfc2119>must</rfc2119> contain only 
             descendants of the parent.  
            Occurs once.  (Note that under the definition of a legal state specification, if
            the parent of the history element is &lt;state&gt; and the default
            state specification contains a multiple states, then, in a conformant SCXML document,
            the 'type' of the history element <rfc2119>must</rfc2119> be 
            "deep" and the states <rfc2119>must</rfc2119> be atomic descendants of a 
            &lt;parallel&gt; element that is itself
         a descendant of the parent &lt;state&gt; element.)</p></item>
          </ulist>
        </div3>
         <p>  If the 'type' of a &lt;history&gt; element
         is "shallow", the SCXML processor <rfc2119>must</rfc2119> record the immediately active
         children of its parent before taking any transition that exits the parent.   
         If the 'type' of a &lt;history&gt; element
         is "deep", the SCXML processor <rfc2119>must</rfc2119> record the active
         atomic descendants of the parent before taking any transition that exits the parent. After the parent state has been
         visited for the first time, for each &lt;history&gt; element, we define the set
         of states that the processor has recorded to be the 'stored state configuration' for that
         history state. We also define the states specified by the 'target' 
         of the &lt;history&gt; element's &lt;transition&gt;
         child to be the 'default stored state configuration' for that element.  
         If a transition is executed that takes the &lt;history&gt; state as its target, the behavior depends on whether the
         parent state has been visited before. If it has, the SCXML processor <rfc2119>must</rfc2119>
         behave as if the transition had taken the stored state configuration for that history state
         as its target.  If it has not, the SCXML processor <rfc2119>must</rfc2119>
         behave as if the transition had taken the default stored state configuration for that history state
         as its target. The Process <rfc2119>must</rfc2119> execute any executable content in the transition after the parent state's onentry handlers, 
         and, in the case where the history pseudo-state is the target of an &lt;initial&gt;
         transition, the executable content inside the &lt;initial&gt; transition.
         (Note that in a conformant SCXML document, a &lt;state&gt; or &lt;parallel&gt; element <rfc2119>may
         </rfc2119> have both "deep" and "shallow" &lt;history&gt; children.) </p>
      </div2>
 <div2 id="LegalStateConfigurations">
	<head> Legal State Configurations and Specifications</head>
	         <p>[This section is  normative.]</p>		
<p>  <termdef id="state-active" name="stateActive">A &lt;state&gt; or &lt;parallel&gt; element is
<term>active</term> if it has been entered by a transition and has not subsequently been 
exited.</termdef></p>
<p><termdef id="state-configuration" name="stateConfiguration">The <term>state configuration</term> of a state machine is the set of currently active states.
</termdef></p>
<p>  
	An SCXML document places the state machine in an initial state configuration
	at initialization time (via the 'initial' attribute of the &lt;scxml&gt; element).  Each
	transition that the state machine takes thereafter places the state machine in another
	state configuration (which need not be distinct from the former one.) A conformant SCXML document  
	<rfc2119>must</rfc2119> place the state machine only in  legal state configurations, where
	a legal state configuration is one that meets the following conditions:</p>
<ul>

	<li>The configuration contains exactly one child  of the &lt;scxml&gt; element.</li>
		<li>The configuration contains one or more atomic states.</li>
		<li>When the configuration contains an atomic state, it contains all
			of its &lt;state&gt; and &lt;parallel&gt; ancestors.</li>
			<li>When the configuration contains a non-atomic &lt;state&gt;,
				it contains one and only one of the state's children.</li>
		<li>If the configuration contains a &lt;parallel&gt; state, it
			contains all of its children.</li>
</ul>
<p>It follows from this definition that if a state machine is in more
	than one atomic state, the atomic states can be traced back through
	a chain of &lt;state&gt; or &lt;parallel&gt; ancestors to a single
	&lt;parallel&gt; ancestor.   </p>
<p>The
	'target' attribute of a &lt;transition&gt; (or the 'initial' attribute of a 
	&lt;state&gt; or &lt;scxml&gt; element) do not in the general case specify a full legal state configuration 
	since	1) they can contain &lt;parallel&gt; or non-atomic &lt;state&gt; elements 2)
	they do not contain the ancestors of the states in the list.  
	We therefore define a legal state specification to be a set of states
	such that 1) no state is an ancestor of any other state on the list, and 2)
	a full legal state configuration results when
	all ancestors and default initial descendants have been added.  (Note that the
	process of adding default initial descendants is recursive, since the 'initial' value
	may itself be non-atomic.)  In a conformant
	SCXML document, the value of an 'initial' attribute or the 'target' of a &lt;transition&gt; 
	<rfc2119>must</rfc2119> either be empty or contain
	a legal state specification. </p>
	<p> In a conformant SCXML
	document, there is an additional requirement on the value of the 'initial' attribute of
		a &lt;state&gt; and on the 'target' of a  &lt;transition&gt; inside an &lt;initial&gt; 
		or &lt;history&gt; element: 
		all the states <rfc2119>must</rfc2119> be descendants of the containing
	&lt;state&gt; or &lt;parallel&gt; element. 
		</p>
	
	</div2>
	



<div2 id="events">
      <head>SCXML Events</head>
               <p>[This section is  normative.]</p>		
      <p>Events are one of the basic concepts in SCXML since they drive most transitions.  The internal
      structure of events is platform-specific as long as the following external interface is observed: </p>
      <ulist>
   <item><p>The SCXML processor <rfc2119>must</rfc2119> make the data contained in an event
   accessible via the '_event' variable, as specified in <specref ref="SystemVariables"/>.</p>
      </item>
      <item><p>The SCXML processor <rfc2119>must</rfc2119> make the event's name
   accessible via the '_event' variable, as specified in <specref ref="SystemVariables"/>.  
   The SCXML processor <rfc2119>must</rfc2119> use this same name value to match against the
   'event' attribute of transitions. </p>
     </item>
      </ulist>
     

      <p>For the most part, the set of events raised during the execution of an SCXML document is 
      application-specific and generated under author control by use of the &lt;raise&gt; and &lt;send&gt; elements.  However,
      certain events are mandatory and generated automatically by the interpreter.  These are
      described in <specref ref="errorsAndEvents"/>.   Platforms <rfc2119>may </rfc2119>
      extend the names of these automatically generated events by adding a suffix. For
      	example, a platform could extend done.state.<em>id</em> with a timestamp suffix and
      	generate done.state.<em>id.timestamp</em> instead.  Because any prefix of done.state.<em>id</em>
      	is also a prefix of done.state.<em>id.timestamp</em>, any transition that matches the former
      	event will also match the latter. </p> 
      	
      	<div3 id="EventDescriptors">
      <head>Event Descriptors</head>
      <p>Like an event name, an event descriptor is a series of alphanumeric characters segmented
      	into tokens by the "." character.  The 'event' attribute of a transition consists
      of one or more such event descriptors separated by spaces. </p> 
      <p>
      	<termdef id="transition-match" name="transitionMatch">A transition <term>matches</term> an event if at least one
      of its event descriptors matches the event's name. </termdef></p>
      <p>
      <termdef id="event-match" name="eventMatch"> An event descriptor <term>matches</term> an event name
      if its string of tokens is an exact match or a prefix of the set of tokens in the event's name.
      In all cases, the token matching is case sensitive. </termdef>
      </p>
      <p> 
      For example, a transition with an 'event' attribute 
      of "error foo" will match event names "error", "error.send", "error.send.failed", etc. (or "foo", 
      "foo.bar" etc.)
      but would not match events named "errors.my.custom", "errorhandler.mistake","errOr.send" or "foobar". </p>
      <p>For compatibility with CCXML, and to make the prefix matching possibly more clear to a reader 
      	of the SCXML document, an event descriptor <rfc2119>may</rfc2119> also  end with the wildcard '.*', 
      	which matches zero or more tokens at the end of the processed event's name.  Note 
      	that a transition with 'event' of "error", one with "error.", and one with "error.*" are functionally equivalent 
      	since they are token prefixes of exactly the same set of event names. </p>
      	<p>An event designator consisting solely of "*" can be used as a 
      		wildcard matching any sequence of tokens, and thus any event. Note that this is 
      		different from a transition lacking the 'event' attribute altogether. Such an eventless 
      		transition does not match any event, but will be taken whenever its 'cond' attribute 
      		evaluates to 'true'. As shown in <specref ref="AlgorithmforSCXMLInterpretation"/>, 
      		the SCXML interpreter will check for such eventless transitions when it first enters a state, 
      		before it looks for transitions driven by internal or external events.      	
      	
      	</p>
      
      </div3>
<div3 id="ErrorEvents">
 	<head>Errors</head>

  <p>Once the SCXML processor has begun executing a well-formed SCXML document,
  	it <rfc2119>must</rfc2119> signal any errors that occur by raising SCXML events whose names begin with 
  	'error.'.  the processor <rfc2119>must</rfc2119> place these events in the internal
       event queue and  <rfc2119>must</rfc2119> process them like any other event. 
      (Note in particular, they are  not processed
      immediately if there are other events in the queue and they are ignored if no transition
       is found that matches them.)  Two error events are defined in this specification: 
      'error.communication' and 'error.execution'.  The former cover errors occurring
while trying to communicate with external entities, such as those arising from 
&lt;send&gt; and &lt;invoke&gt;, while the latter category consists of errors
internal to the execution of the document, such as those arising from expression
evaluation. 
</p> 

<p> 
The set of error events may be extended in future versions of this
specification.  However, the set of names beginning with 'error.platform' 
is reserved for platform- and application-specific errors.  Therefore
applications and platforms <rfc2119>may</rfc2119> extend the set of errors defined in this
specification in two ways.  First by adding a suffix to an error name defined
in this specification, and second by using 'error.platform' with or without
a suffix.  In addition, platforms <rfc2119>may</rfc2119> include additional information about
the nature of the error in the 'data' field of the event.  
See <specref ref="SystemVariables"/>
for details.
</p>
       <p>Note however that authors can arrange for otherwise
       unhandled errors to cause the interpreter to exit by creating a transition with
       "event" attribute of 'error' and a target of any top-level final state (i.e. one that is a child
       of &lt;scxml&gt;).   If such a transition T is placed in a state S, it will cause 
       the state machine to terminate on any error that is raised in S or one of its substates 
       and is not handled by another transition that is placed in a substate of S or in S
       and preceding T in document order.
       </p>	
      </div3>  
      <div3 id="errorsAndEvents">
      		<head>List of Errors and Events</head>
      	<p>The following events are generated automatically by the SCXML implementation under
      		conditions defined elsewhere in this document.</p>

            <table cellpadding="2" cellspacing="2" border="1" width="100%" summary="errors and events">
              <tbody>
               <tr>
                  <th align="center">Name</th>
                  <th align="center">Description</th>
                  <th align="center">Defined in</th>
                  <th align="center">See also</th>
                </tr>
                <tr>
                  <td align="center">done.state.<em>id</em></td>                  
                  <td>Indicates that the state machine has entered a final substate of
                  	state <em>id</em>.</td>
                  <td><specref ref="final"/></td>
                  <td><specref ref="CoreIntroduction"/></td>
                </tr>
                <tr>
                  <td align="center">done.invoke.<em>id</em></td>                  
                  <td>Indicates that the invoked process with invokeid <em>id</em> has completed processing.</td>
                  <td><specref ref="invoke"/></td>
                  <td><specref ref="final"/>, exitInterpreter procedure in <specref ref="AlgorithmforSCXMLInterpretation"/> </td>
                </tr>
                <tr>
                  <td align="center">error.communication</td>                  
                  <td>Indicates that an error has occurred while trying to communicate with an external entity.</td>
                  <td><specref ref="ErrorEvents"/></td>
                  <td><specref ref="send"/>, <specref ref="SCXMLEventProcessor"/>, <specref ref="BasicHTTPEventProcessor"/></td>
                </tr>
                <tr>
                  <td align="center">error.execution</td>                  
                  <td>Indicates that an error internal to the execution of the document has occurred, such as one arising from expression evaluation.</td>
                  <td><specref ref="ErrorEvents"/></td>
                  <td><specref ref="foreach"/>, <specref ref="assign"/>, <specref ref="param"/>, <specref ref="ConditionalExpressions"/>, <specref ref="LocationExpressions"/>, <specref ref="ValueExpressions"/>, <specref ref="ErrorsinExpressions"/>, <specref ref="SystemVariables"/>, <specref ref="send"/>, <specref ref="ecma_location_expressions"/>, <specref ref="ecma_assign"/></td>
                </tr>
                <tr>
                  <td align="center">error.platform</td>                  
                  <td>Indicates that a platform- or application-specific error has occurred.</td>
                  <td><specref ref="ErrorEvents"/></td>
                  <td></td>
                </tr>
               </tbody>
            </table>
        </div3>
 </div2>

<div2 id="SelectingTransitions">
	<head>Selecting and Executing Transitions</head>
	         <p>[This section is  normative.]</p>		
	<p>To simplify the following definitions, we introduce the event NULL.  NULL has no name and
		is used only in these definitions. It never occurs in the event queues of an SCXML Processor.  All
		other events have names and are distinct from NULL. (In effect, NULL is a pseudo-event that is
		used in these definitions as a trigger for eventless transitions.) </p>
		
	<p><termdef id="transition-enabled" name="transitionEnabled">A transition T is <term> enabled </term> by named event E  in atomic state S if a) T's source state
	is S or an ancestor of S,and b) T matches E's name (see <specref ref="EventDescriptors"/>)
	and c) T lacks a 'cond' attribute
	or its 'cond' attribute evaluates to "true".  A transition is <term> enabled </term> by NULL in
	atomic state S if a) T lacks an 'event' attribute, and b) T's source state is S or an ancestor of S and c) T lacks an 'cond' attribute or
	its 'cond' attribute evaluates to "true".  (Note that such a transition can never be
	enabled by any named event.)</termdef>
	</p>
	
	
	
	<p><termdef id="source-state" name="sourceState"> The <term>source state</term> of a transition is the &lt;state&gt; or &lt;parallel&gt; element
	that it occurs in.  The <term>effective target state(s)</term> of the transition is the state or set of states specified
	by its 'target' attribute, with any history states being replaced by the corresponding stored
	state configuration or default stored state configuration.  The <term>complete target set</term> of a transition consists of all the states
	that will be active after the transition is taken.  It contains the effective target states of the transition
	plus all their ancestors, expanded by the recursive application of the following two operations:
	1) if any &lt;parallel&gt; element is a member of the set, any of its children that are not members of
	the set must be added	2) if any compound &lt;state&gt; is in the set and none of its children is 
	in the set, its default	initial state(s) are added to the set.  Any state whose child(ren) are added
	to the complete target set by clause 2 is called a <term>default entry state</term>.
	</termdef></p>
	
	<p><termdef id="exit-set" name="exitSet">The <term>exit set</term> of a transition in configuration C is the set of states that are exited
	when the transition is taken when the state machine is in C.  If the transition does not contain a 'target', its exit set
	is empty.  Otherwise (i.e., if the transition contains a 'target'), if its 'type' is "external", its exit set
consists of  all active states in C that are proper descendants of
	the <a href="#LCCA">Least Common Compound Ancestor (LCCA)</a>
  of the source and target states.  Otherwise, if the transition has 'type' "internal", its source state
  is a compound state,  
  and all its target states are proper descendants of its source state, the exit
  set consists of all active states in C that are proper descendants of its source state.
  (If a transition has 'type' of "internal", but its source state is not compound or its target states are 
  not all proper descendants
  of its source state, its exit set is defined as if it had 'type' of "external".  The exit
  set of a set of transitions is the union of the exit sets of the individual transitions.	
	</termdef></p>
	
	<p><termdef id="entry-set" name="entrySet">The <term>entry set</term> of a transition in configuration C is the set of states that
	are entered when the transition is taken.  If a transition does not contain a 'target',
	its entry set is empty.  Otherwise, it consists of all members of the
	transition's complete target set that that are not
	currently active or are in the exit set.  (Thus the entry set consists
	of all members of the transition's complete target set that will not be active
	once the states in the exit set have been exited.) The entry set of a set of transitions is
	the union of the entry sets of the individual transitions.</termdef></p>
	
	<p><termdef id="optimally-enabled" name="optimallyEnabled">A transition T is <term>optimally enabled </term> by event E in atomic state S if a) T is enabled
	by E in S  and b) no transition that precedes T in document order 
	in T's source state is enabled by E in S and c) no transition is enabled by E in S in any descendant of
	T's source state.</termdef></p>	
	
<p><termdef id="transition-conflict" name="transitionConflict">Two transitions T1 and T2 <term>conflict</term> in state configuration C
if their exit sets in C have a non-null intersection.</termdef></p>
<p>N.B.  If two transitions conflict, then taking them both may lead to an illegal configuration.  
	Hence,  only one of the transitions may safely be taken.
	In order to resolve conflicts between transitions, we assign priorities to transitions as follows:  
	 let transitions T1 and T2 conflict, where T1 is optimally enabled in atomic state S1, and T2 is
	optimally enabled in atomic state S2, where S1 and S2 are both active.  We say that T1
	has a higher priority than T2 if a) T1's source state is a descendant
	of T2's source state, or b) S1 precedes S2 in document order. </p>

	<p><termdef id="optimal-transition-set" name="optimalTransitionSet">The <term>optimal transition set </term> enabled by event E in state configuration C is
	the largest set of transitions such that a) each transition in the set is optimally enabled
	by E in an atomic state in C b) no transition conflicts with another transition
	in the set c) there is no optimally enabled transition outside the set that has a higher
	priority than some member of the set. </termdef>  </p>
	
		<p><termdef id="microstep" name="Microstep">A <term>microstep</term> consists of the execution of the transitions in
	an optimal enabled transition set.</termdef></p>
	
	<p><termdef id="macrostep" name="Macrostep">A <term>macrostep</term> is a series of one or more microsteps ending
	in a configuration where the internal event queue is empty and no transitions are enabled
	by NULL. </termdef></p>
	
	<p>To execute a microstep, the SCXML Processor <rfc2119>must</rfc2119> execute the
	transitions in the corresponding optimal enabled transition set. To execute a set of transitions,
	the SCXML Processor <rfc2119>must</rfc2119> first exit all the states in the transitions'
	exit set in <a href="#exitOrder"> exit order</a>.  It <rfc2119>must</rfc2119> then execute the executable
	content contained in the transitions in document order.  It <rfc2119>must</rfc2119> then
	enter the states in the transitions' entry set in <a href="#entryOrder"> entry order</a>.</p>
	
	<p>To exit a state, the SCXML Processor <rfc2119>must</rfc2119> execute the executable content
	in the state's &lt;onexit&gt; handler.  Then it <rfc2119>must</rfc2119> cancel any ongoing invocations
	that were triggered by that state.  Finally, the Processor <rfc2119>must</rfc2119> remove
	the state from the active state's list.</p>
	
	<p>To enter a state, the SCXML Processor <rfc2119>must</rfc2119> 
	add the state to the active state's list.  Then it <rfc2119>must</rfc2119> execute the executable content
	in the state's &lt;onentry&gt; handler.   If the state is a default entry state and has
	an &lt;initial&gt; child, the SCXML Processor <rfc2119>must</rfc2119> then execute the executable content
	in the &lt;initial&gt; child's &lt;transition&gt;.   
	</p>
	
		<p>At startup, the SCXML Processor <rfc2119>must</rfc2119> place the state machine in the 
	configuration specified by the 'initial' attribute of the &lt;scxml&gt; element.</p>
	
	<p>After entering the initial configuration, and after executing each microstep, 
		the SCXML Processor <rfc2119>must</rfc2119> check the state configuration for &lt;final&gt; states
		that it has entered during the microstep.  If it has entered a &lt;final&gt; state that is a child
		of &lt;scxml&gt;, it <rfc2119>must</rfc2119> halt processing.  If it has entered a &lt;final&gt; 
		state that is a child of a compound state, it <rfc2119>must</rfc2119> generate the event
		done.state.<em>id</em>, where <em>id</em> is the id of the compound state.  If the compound
		state is itself the child of a &lt;parallel&gt; element, and all the &lt;parallel&gt; element's
		other children are in final states, the Processor <rfc2119>must</rfc2119> generate the event
		done.state.<em>id</em>, where <em>id</em> is the id of the &lt;parallel&gt; elements.</p>
		<p>  
	After checking the state configuration, the Processor <rfc2119>must</rfc2119> select the optimal transition set enabled by NULL in the current configuration.  If the set is not empty, it <rfc2119>must</rfc2119> execute it as a microstep. If
		the set is empty, the Processor <rfc2119>must</rfc2119> remove events from the internal event queue 
		until the queue is empty or it finds an event that enables a non-empty 
		optimal transition set in the current configuration.  If it finds such  a  set,
		the processor <rfc2119>must</rfc2119>
		then execute it as a microstep. (Otherwise the internal event queue is empty and the Processor
		has completed a macrostep.)</p>
		
		<p>After completing a macrostep, the SCXML Processor <rfc2119>must</rfc2119> execute in document 
		order the 
		&lt;invoke&gt; handlers in all states that have been entered since the completion of the
		last macrostep.  Then the Processor <rfc2119>must</rfc2119> remove events from the external event 
		queue, waiting till events appear if necessary, until
		it finds one that enables a non-empty optimal transition set in the current configuration. 
		The Processor <rfc2119>must</rfc2119> then execute that set as a microstep. </p>

    </div2>    
    
      
      <div2 id="IDs">
	<head>IDs</head>
	         <p>[This section is  normative.]</p>		
	<p>In a conformant SCXML document, the values of all attributes of type "id" <rfc2119>must</rfc2119> be unique within the session.
		When such an attribute is defined to be optional and the author omits it, then, for elements other than
		&lt;send&gt; and &lt;invoke&gt;, the SCXML processor
		 <rfc2119>must</rfc2119> generate a unique id automatically 
		at document load time.  (Note that Such system generated IDs
		cannot normally be referenced elsewhere in the document because they are not known to the author.  
		In particular,
		a state with a system generated ID cannot be the target of a transition.)  The ids for &lt;send&gt;
		and &lt;invoke&gt; are subtly different.  In a conformant SCXML document, they <rfc2119>must</rfc2119>
		 be unique within the session, but in the case
		where the author does not provide them, the processor <rfc2119>must</rfc2119> generate a new unique ID not at
		load time but <em>each time
		the element is executed</em>.  Furthermore the attribute 'idlocation' can be used to 
		capture this automatically generated id.  Finally note that the automatically generated id 
		for &lt;invoke&gt; has a special format. See <specref ref="invokeattrs"/> for details. The
		SCXML processor <rfc2119>may</rfc2119> generate all other
		ids in any format, as long as they are unique.  </p>
		</div2>
		   
      </div1>


    <div1 id="executable">
      <head>Executable Content</head>
 <div2 id="ExecutableIntroduction">
 	<head>Introduction</head>
 	<p>[This section is informative.]</p>
      <p>
        Executable content allows the state machine to <em>do</em> things.  It provides
        the hooks that allow an SCXML session to modify its data model and interact with external
        entities.  Executable content consists of actions that are performed as 
        part of taking transitions.  In particular, executable content occurs inside
        &lt;onentry&gt; and &lt;onexit&gt; elements as well as inside transitions.  When
        the state machine takes a transition, it executes the &lt;onexit&gt; executable
        content in the states it is leaving, 
        followed by the content in the transition,
        followed by the &lt;onentry&gt; content in the states it is entering.    </p>
        <p>This standard defines elements of executable content which can raise events<specref ref="raise"/>,
        	communicate with external entities <specref ref="send"/>, log information <specref ref="log"/> 
        	execute scripts <specref ref="script"/>and modify the data model <specref ref="assign"/>, 
        	as well	as control constructs to conditionalize execution <specref ref="if"/> and to
        	iterate over the items in a collection <specref ref="foreach"/>.  In addition, SCXML 
        	implementations are allowed to define their own, platform-specific executable content (see
        	<specref ref="extensibility"/>).  
        	</p>
        
        </div2>

    
<div2 id="raise">
         <head>&lt;raise&gt;</head>
                  <p>[This section is  normative.]</p>		
         <p>The &lt;raise&gt; element raises an event in the current SCXML session. 

           Note that the event will not be processed until the current block of executable content has
         completed and all events that are already in the internal 
         event queue have been processed.  
         For example, suppose the &lt;raise&gt; element occurs first in the &lt;onentry&gt; 
         handler of state S followed by executable content elements ec1 and ec2.  If event e1 is
         already in the internal event queue when S is entered, the event generated by &lt;raise&gt;
         will not be processed until ec1 and ec2 have finished execution and
         e1 has been processed.   
         </p>
       

        <div3>
        <head>Attribute Details</head>
                <xi:include href="attributes/event.xml.html"/>
        </div3>

        <div3>
        <head>Children</head>
None.
        </div3>
<p>         The SCXML processor <rfc2119>must</rfc2119> place the event that is generated at the rear of the 
         session's internal event queue.  </p>
       </div2>	

      <div2 id="if">
          <head>&lt;if&gt;</head>
                   <p>[This section is  normative.]</p>		
            <p>&lt;if&gt; is a container for conditionally executed elements.  </p> 


          <div3>
            <head>Attribute Details</head>
            <xi:include href="attributes/if.xml.html"/>
          </div3>

<div3>
<head>Children</head>
<ulist>
<item><p>&lt;elseif&gt;  Occurs 0 or more times.  See <specref ref="elseif"/></p></item>
<item><p>&lt;else&gt;   Occurs 0 or 1 times. See <specref ref="else"/></p></item>
<item><p> The other children of &lt;if&gt; consist of executable content.  Note that 
since &lt;if&gt; itself is executable content, nested &lt;if&gt; statements are allowed.</p></item>
</ulist>
</div3>
<p>The behavior of &lt;if&gt; is defined in terms of partitions of executable content.  The first partition
	consists of the executable content between the &lt;if&gt; and the first &lt;elseif&gt;, 
	&lt;else&gt; or &lt;/if&gt; tag.  Each &lt;elseif&gt; tag defines a partition that extends from it
	to the next &lt;elseif&gt;, &lt;else&gt; or &lt;/if&gt; tag.  The &lt;else&gt; tag
	defines a partition that extends from it to the closing &lt;/if&gt; tag. 
	In a conformant SCXML document, a partition <rfc2119>may</rfc2119> be empty.
           In a conformant SCXML document, 
           &lt;else&gt; <rfc2119>must</rfc2119>
           occur after all &lt;elseif&gt; tags.  </p>
<p>
	When the &lt;if&gt; element is executed, the SCXML processor <rfc2119>must</rfc2119> execute
the first partition in document order that is defined by a tag whose  'cond' attribute
evaluates to true, if there is one.  Otherwise, it <rfc2119>must</rfc2119> execute the partition
defined by the &lt;else&gt; tag, if there is one.  Otherwise it <rfc2119>must not</rfc2119> execute 
any of the executable content.</p>


            <p>Here is an example:</p>
            <eg xml:space="preserve" >&lt;if cond="cond1"&gt;
  &lt;!-- selected when "cond1" is true --&gt;
&lt;elseif cond="cond2"/&gt;
  &lt;!-- selected when "cond1" is false and "cond2" is true --&gt;
&lt;elseif cond="cond3"/&gt;
  &lt;!-- selected when "cond1" and "cond2" are false and "cond3" is true --&gt;
&lt;else/&gt;
  &lt;!-- selected when "cond1", "cond2", and "cond3" are false --&gt;
&lt;/if&gt;
            </eg>
</div2>
        
<div2 id="elseif">
          <head>&lt;elseif&gt;</head>
                   <p>[This section is  normative.]</p>		
          <div3>
            <head>Overview</head>
            <p>&lt;elseif&gt; is an empty element that partitions the content of an &lt;if&gt;, and provides a condition that
            determines whether the partition is executed.  </p>
          </div3>
          <div3>
 
          </div3>

        </div2>

<div2 id="else">
          <head>&lt;else&gt;</head>
                   <p>[This section is  normative.]</p>		
          <div3>
            <head>Overview</head>
            <p>&lt;else&gt; is an empty element that partitions the content of an &lt;if&gt;. 
            	It is equivalent to an &lt;elseif&gt; with a "cond" that always evaluates
            to true.  </p>
          </div3>
          <div3>
            <head>Attribute Details</head>
            <p>None. </p>
          </div3>
        </div2>
        
<div2 id="foreach">
	<head>&lt;foreach&gt;</head>
	<div3>
		         <p>[This section is  normative.]</p>		
		<head>Overview</head>
<p>		The &lt;foreach&gt; element allows an SCXML application to iterate through a collection 
			in the data model and to execute the actions contained within it 
				for each item in the collection. 
</p> 
</div3>
  <div3>
  <head>Attribute Details</head>
    <xi:include href="attributes/foreach.xml.html"/>

    </div3>
<div3>
<head>Children</head>
<p>The children of &lt;foreach&gt; consist of one or more items of executable content.  
	(Note that they are considered
	to be part of the same block of executable content as the parent &lt;foreach&gt; element.)
</p>
</div3>

<p>The SCXML processor <rfc2119>must</rfc2119> declare a new variable if the one specified 
by 'item' is not already defined.  If 'index' is present, the SCXML processor 
<rfc2119>must</rfc2119> declare a new variable if the one specified 
by 'index' is not already defined.  If 'array' does not evaluate to a legal iterable collection,
or if 'item' does not specify a legal variable name, 
the SCXML processor <rfc2119>must</rfc2119> terminate execution of the &lt;foreach&gt; element and the
block that contains it, and place the error error.execution on the internal 
event queue. 
</p>
<p>
The SCXML processor <rfc2119>must</rfc2119> act as if it has made a shallow copy of the collection
produced by the evaluation of 'array'.  Specifically, modifications to the collection during the
execution of &lt;foreach&gt; <rfc2119>must not</rfc2119> affect the iteration behavior.  
The SCXML processor <rfc2119>must</rfc2119> start with the first item in the collection and proceed
to the last item in the iteration order that is defined for the collection.  (This order 
depends on the
data model in use. ) 
For each item in turn, the processor <rfc2119>must</rfc2119> assign it to the item variable.  (Note that the
assigned value <rfc2119>may</rfc2119> be null or undefined  
if the collection contains a null or undefined item.)  After making the assignment, the SCXML processor 
<rfc2119>must</rfc2119>
evaluate its child executable content.  It <rfc2119>must</rfc2119> then proceed to
the next item in iteration order.  
If the evaluation of any child element causes an error, the processor <rfc2119>must</rfc2119>
cease execution of the &lt;foreach&gt; element and the block that contains it.  
(Note that SCXML does not provide break 
functionality to interrupt &lt;foreach&gt;, however targetless and/or eventless transitions 
can provide sophisticated  iterative behavior within the SCXML application itself.)
</p>
	
	</div2>

<div2 id="log">
          <head>&lt;log&gt;</head>
                   <p>[This section is  normative.]</p>		
          <div3>
            <head>Overview</head>
            <p>&lt;log&gt; allows an application to generate a logging or debug message. 

            </p>
          </div3>
          <div3>
            <head>Attribute Details</head>
            <xi:include href="attributes/log.xml.html"/>
          </div3>
          <div3>
          	<head>Children</head>
          	<p>None. </p>
          	</div3>
<p>            	The manner in which the
            message is displayed or logged is platform-dependent. 
             The SCXML processor <rfc2119>must</rfc2119> ensure that &lt;log&gt;
             has no side-effects on document interpretation.</p>
      </div2>
<div2 id="profile-dependentexecutablecontent">
<head>Other Executable Content</head>
         <p>[This section is  normative.]</p>		
<p>The following elements of executable content are defined elsewhere in this specification.  
	They <rfc2119>may</rfc2119> occur wherever executable content is allowed and <rfc2119>must not</rfc2119>
	occur anyplace else. </p>
	<ulist>
     <item><p>&lt;assign&gt;.  
     Changes the value of a location in the data model.  See <specref ref="assign"/> for details.</p></item>
     <item><p>&lt;script&gt;.  
     Provides scripting capabilities. See <specref ref="script"/> for details.</p></item>
     <item><p>&lt;send&gt;.  
     Sends an event to a specified destination. See <specref ref="send"/> for details.</p></item>
     <item><p>&lt;cancel&gt;.  
     Cancels an event that was to be sent  See <specref ref="cancel"/> for details.</p></item>
   </ulist>
		

</div2>
 
         <div2 id="EvaluationofExecutableContent">
        	<head>Evaluation of Executable Content</head>
        	         <p>[This section is  normative.]</p>		
        	<p>Wherever executable content is permitted, 
        an arbitrary number of elements <rfc2119>may</rfc2119> occur.  Such a sequence of
        elements of executable content is called a block.  For example, if transition t 
        takes the state machine from atomic state S1 to atomic state S2, there are three blocks of
        executable content executed: the one in the &lt;onexit&gt; handler of S1,
        the one inside t, and the one inside the &lt;onentry&gt; handler of S2.  The SCXML processor
        <rfc2119>must</rfc2119> execute the elements of a block 
 in document order.  If the processing
      of an element causes an error to be raised, the processor  <rfc2119>must not</rfc2119>
      process the remaining elements of 
      the block. (The execution of other blocks of executable content is not affected.) 
      </p>
      <p>
      Events
      raised during the processing of executable content are treated like any other events.  
    
      Note in particular, that error events
      will not be removed from the queue and processed until all events preceding them in the queue
      have been processed.  See <specref ref="ErrorEvents"/>.
      for details.</p>
 </div2>        
<div2 id="extensibility">
<head>Extensibility of Executable Content</head>
         <p>[This section is  normative.]</p>		
<p>Implementations <rfc2119>may</rfc2119> provide
additional executable content corresponding to special features of their implementations.
The functionality of such platform-specific content is not restricted, except 
that it <rfc2119>must not</rfc2119> cause transitions or any form of change of state (except indirectly,
by raising events that trigger transitions).  
Note that SCXML treats the executable content triggered by a transition as a 
single blocking operation and that no events are processed until all the executable content 
has completed.  For example, when taking a transition into state S, the SCXML processor will not process any 
events or take any transitions until all &lt;onentry&gt; handlers in S have finished.  It is thus
important that all executable content, including platform-specific extensions, execute swiftly. </p>
        
<p> In a conformant SCXML document any extensions to executable content <rfc2119>must not</rfc2119> 
be defined the 'scxml' namespace.  (Note that the schema <specref ref="schemas"/> allows elements
from arbitrary namespaces inside blocks of executable content.)  The following example shows
the incorporation of CCXML functionality (see <bibref ref="CCXML"/>) into SCXML.  In particular
an &lt;accept&gt; element in the 'ccxml' namespace is invoked as executable content
inside a transition.</p> 

      <eg space="preserve" xml:space="preserve">
&lt;transition event="ccxml:connection.alerting"&gt;
  &lt;ccxml:accept connectionid="_event.data.connectionid"/&gt;
&lt;/transition&gt;</eg>
        
<p>This markup is legal on any SCXML interpreter, but the behavior of 
&lt;accept&gt; element is platform-dependent. See <specref ref="ConformingProcessors"/>
for details.</p>
<p>A general method for implementing extensions using the &lt;send&gt; element 
is presented in <specref ref="custom_action"/>.</p>
</div2>

</div1>

<div1 id="data-module">

<head>Data Model and Data Manipulation</head>
<div2 id="DataModelIntroduction">
	<head>Introduction</head>
	<p>[This section is informative.]</p>
<p>The Data Model offers the capability of storing, reading, and modifying a set of
data that is internal to the state machine.  This specification does not mandate
any specific data model, but instead defines a set of abstract capabilities that
can be realized by various languages, such as ECMAScript or XML/XPath.  Implementations
may choose the set of data models that they support.  In addition to
the underlying data structure, the data model defines a set of expressions 
as described in <specref ref="Expressions"/>. These expressions are used to
refer to specific locations in the data model, to compute values to assign to those
locations, and to evaluate boolean conditions.   Finally, the data model includes
a set of system variables, as defined in <specref ref="SystemVariables"/>, which are automatically 
maintained by the SCXML processor.</p>

<p>The data model is defined via the <specref ref="datamodel"/> element, which
	contains zero or more <specref ref="data"/> elements, each of which defines a single
	data element and assigns an initial value to it.  These values may be specified in-line
	or loaded from an external source.  They can then be updated
	via the <specref ref="assign"/> element.  The <specref ref="donedata"/>, <specref ref="content"/>, and <specref ref="param"/> elements
	can be used to incorporate data into communications with external entities.
	Finally, the <specref ref="script"/> element permits the incorporation of a scripting language.</p>

<p>The interpretation of these elements depends on the data model in question, and 
	not all elements are supported in all data models.  For the details of specific data models, see <specref ref="profiles"/>.</p>
</div2>

<div2 id="datamodel">
      <head>&lt;datamodel&gt;</head> 
               <p>[This section is  normative.]</p>		
           <p>&lt;datamodel&gt; is a wrapper element
     which encapsulates any number of &lt;data&gt; elements, each of which defines a single data 
     object.   The exact nature of the data object depends on the data model language used.  
      </p>
     
     
      <div3>
      <head>Attribute Details</head>
        <p>None.</p>
      </div3>
      <div3>
      <head>Children</head>
     <ulist>
           <item><p>&lt;data&gt;  Occurs 0 or more times. Each instance defines a named
           data element. </p></item>
    </ulist>
    </div3>
    </div2>   
       <div2 id="data">
         <head>&lt;data&gt;</head>
                  <p>[This section is  normative.]</p>		
<p>The &lt;data&gt; element is used to declare and populate portions of the data model. </p>
         

         <div3>
         <head>Attribute Details</head>
         <xi:include href="attributes/data.xml.html"/>
         </div3>
         <div3>
         <head>Children</head>
         <p>The children of the &lt;data&gt; element represent
         an in-line specification of the value of the data object. </p>    
         <p>In a conformant SCXML document, a &lt;data&gt; element <rfc2119>may</rfc2119> have
         either a 'src' or an 'expr' attribute, but  <rfc2119>must not</rfc2119> have both.  
         Furthermore, if either attribute is present, the element
         <rfc2119>must not</rfc2119> have any children.   Thus 'src', 'expr' and 
         children are mutually
         exclusive in the &lt;data&gt; element.</p>
        <p> The SCXML Processor <rfc2119>must</rfc2119> use
         any values provided by the environment at instantiation time in place of those contained in 
         the top-level &lt;data&gt;
         elements.  (Top-level data elements are those 
         that are children of the &lt;datamodel &gt; element 
         that is a child of &lt;scxml&gt;). 
          The manner in which the environment specifies these overriding values is platform-dependent.</p>
          
          <p>If the 'expr' attribute is present, the Platform <rfc2119>must</rfc2119> evaluate 
          the corresponding expression at the time specified by the 'binding' attribute of &lt;scxml&gt;
          and <rfc2119>must</rfc2119> assign the resulting value as the value of the data element.
          If the 'src' attribute is present, the Platform <rfc2119>must</rfc2119> fetch
          the specified object at the time specified by the 'binding' attribute of &lt;scxml&gt;
          and <rfc2119>must</rfc2119> assign it as the value of the data element.
          If child content is specified, the Platform <rfc2119>must</rfc2119>  assign it as 
          the value of the data element at the time specified by the 'binding' attribute of &lt;scxml&gt;.
          Note that in the latter two cases, the interpretation of the object or content will depend on the 
          data model.  See <specref ref="profiles"/> for details.  If the value specified for a &lt;data&gt; element (by 'src', children, or the environment) is not a legal data value, 
          the SCXML Processor <rfc2119>must</rfc2119> raise place error.execution in the 
          internal event queue and <rfc2119>must</rfc2119> create an empty data element 
          in the data model with the specified id.
          </p> 
          <p>Implementations <rfc2119>may</rfc2119> predeclare and predefine variables in the data model.  
          However, conformant SCXML implementations <rfc2119>should  not</rfc2119> assume the 
          existence of any predeclared or 
          	predefined variables (i.e., ones not explicitly defined by &lt;data&gt;).</p>
          	
          	<p>Note that this specification does not define any way to modify the data model 
	except by&lt;assign&gt;, &lt;finalize&gt;, and possibly platform-specific elements of 
	executable content.  In particular, no means is defined  for external entities to 
	modify the data model.  In this sense the data model is local to the SCXML session 
	and the SCXML Processor checks for eventless transitions (i.e. ones that are triggered 
	based only on the state of the data model) only after entering a state or processing an event.   
	However in some deployments it may be possible for external entities to modify the data model.  
	For example,  if SCXML is implemented in JavaScript in a  browser, the scope of a document's 
	data model is always accessible through the main window object and thus JavaScript code 
	elsewhere in the window can modify the data model independent of the SCXML interpretation algorithm.  
Such a situation can lead to race conditions and unpredictable behavior
</p>


       </div3>
       
<div3 id="DataBinding">
	<head>Data Binding</head>
	 <p>
     Authors control when the initial
     values are assigned to the data elements by means of the 'binding' attribute
     on the &lt;scxml&gt; element.  When 'binding' is assigned the value "early" 
     (the default), the SCXML Processor <rfc2119>must</rfc2119> create all data elements 
     and assign their 
     initial values at document initialization time.  When 'binding' is assigned
     the value "late", the SCXML Processor <rfc2119>must</rfc2119> create the data elements at
     document initialization time, but <rfc2119>must</rfc2119> assign the specified initial value to
     a given data element only when the state that contains it is entered
     for the first time, before any &lt;onentry&gt; markup.  (The value of the data element between
     the time it is created and the time its parent state is first entered will
     depend on the data language chosen.  The initial value specified by 'expr', 'src' or
     in-line content will be assigned to the
     data element even if the element already has a non-null value when the parent state is first entered.)
     
     	</p>
 

	</div3>
</div2>

<div2 id="assign">
	       <head>&lt;assign&gt;</head>  
	                <p>[This section is  normative.]</p>		
       <p> The &lt;assign&gt; element is used to modify the data model. </p>

         <div3>
         <head>Attribute Details</head>
         <xi:include href="attributes/assign_dm.xml.html"/>
        </div3>
         
         <div3>
         <head>Children</head>
         <p>The children of the &lt;assign&gt;element provide
         an in-line specification of the legal data value (see <specref ref="ValueExpressions"/>) 
         to be inserted into the data model at the specified location.   </p>
         </div3>
        <p>  A conformant SCXML document <rfc2119>must</rfc2119> specify either "expr" or 
        children of &lt;assign&gt;, but not both.   
        	</p>
<p>Assignment to a data model is done by using a location expression to denote the part
of the data model where the insertion is to be made.  
If the location expression does not denote a valid location in the data model or if the value specified
(by 'expr' or children) is not a legal value for the location specified, 
the SCXML Processor <rfc2119>must</rfc2119> place the error 'error.execution' in the internal event queue.  Otherwise,
the SCXML Processor <rfc2119>must</rfc2119> place the specified value at the specified location. 
Note that the nature of the insertion and the definition of a legal value depends on the 
data model language used.  Note also that data models <rfc2119>may</rfc2119> support additional attributes
for &lt;assign&gt; beyond those specified here.  See <specref ref="profiles"/> for details.  
</p>

</div2>
         
         <div2 id="donedata">
        <head>&lt;donedata&gt;</head>
                 <p>[This section is  normative.]</p>		
        <p>A wrapper element holding data to be returned
        	when a &lt;final&gt; state is entered.  
      </p> 

        <div3>
        	<head>Attribute Details</head>
        	<p>None.</p>
        </div3>
        <div3>
        		<head>Children</head>
        		<ulist>       			
        			<item><p>&lt;content&gt;.  Specifies data to include in the event.
        			May occur 0 or 1 times.  See <specref ref="content"/>.</p></item>
        			     <item><p> &lt;param&gt;  Extracts data from the data model to include in the event.
        			See <specref ref="param"/> for details. May occur 0 or more times.</p></item>
        			</ulist>
 
        </div3>
  
   <p> A conformant SCXML document <rfc2119>must</rfc2119> specify either a single &lt;content&gt;
   element or one or more &lt;param&gt; elements as children of &lt;donedata&gt;, but not both.</p> 
 <p>In cases where the SCXML Processor generates
        	a 'done' event upon entry into the final state, it <rfc2119>must</rfc2119> evaluate the
        	&lt;donedata&gt; elements &lt;param&gt; or &lt;content&gt; children and place the
        	resulting data in the
        				_event.data field.  The exact format of that 
            data will be determined by the data model (see <specref ref="profiles"/> for details). 
            In other cases (namely when the &lt;final&gt; element is a child of &lt;scxml&gt; 
            and the state machine has not been triggered by &lt;invoke&gt;), the SCXML Processor 
            <rfc2119>should</rfc2119> return the data to the environment in an implementation-dependent
            manner.</p>
        </div2>
       <div2 id="content"> 
      <head>&lt;content&gt; </head>
               <p>[This section is  normative.]</p>		
      <p>A container element holding data to be passed to an external service.  </p>
      <div3>
      <head>Attribute Details</head>
  
        <xi:include href="attributes/content.xml.html"/>
      </div3>
      <div3>
         <head>Children </head>
         <p>A conformant SCXML document <rfc2119>must not</rfc2119> specify both the 'expr' attribute and 
         child content.  When present, the children of &lt;content&gt; 
          <rfc2119>may</rfc2119> consist of text, XML from any
         namespace, or a mixture of both. </p>

      </div3>
      <p>
      	The use of the &lt;content&gt; element depends on the context
         in which it occurs.  See <specref ref="donedata"/>,
         <specref ref="send"/> and <specref ref="invoke"/> for details. 
         When the SCXML Processor evaluates the &lt;content&gt; element, if the 'expr' value expression is present, 
         the Processor <rfc2119>must</rfc2119> evaluate it and use the result as the output of the 
         &lt;content&gt; element.
         If the evaluation of 'expr' produces an error, the Processor <rfc2119>must</rfc2119> place
         error.execution in the internal event queue and use the empty string as the value of the
         &lt;content&gt; element.  If the 'expr' attribute is not present, the Processor <rfc2119>must</rfc2119>
         use the children of &lt;content&gt; as the output. The interpretation of the output of the
         &lt;content&gt; element depends on the data model.  See <specref ref="profiles"/> for details.
         For the use of namespaces
         inside &lt;content&gt;, see <specref ref="content_and_namespaces"/>.</p>
        </div2>       	      
 <div2 id="param">
 	        <head>&lt;param&gt;</head>
 	                 <p>[This section is  normative.]</p>		
 	<p>The &lt;param&gt; tag provides a general way of identifying
 		a key and a dynamically calculated value which can be passed to an external service 
 		or included in an event. </p>
     
         <div3>
         <head>Attribute Details</head>
        <xi:include href="attributes/param.xml.html"/>
 
 <p> A conformant SCXML document <rfc2119>must</rfc2119> specify either the 'expr' attribute
 of &lt;param&gt; or the 'location' attribute, but <rfc2119>must not</rfc2119> specify both.   
        If the 'location' attribute
          does not refer to a valid location in the data model, or if the evaluation
         of the 'expr' produces an error, the SCXML Processor <rfc2119>must</rfc2119> place
         the error 'error.execution' on the internal event queue and <rfc2119>must</rfc2119> ignore the name and 
         value.  
         Otherwise the use of the name and value depends on the context
         in which the &lt;param&gt; element occurs.  See <specref ref="donedata"/>,
         <specref ref="send"/> and <specref ref="invoke"/> for details.
         
         </p>
         </div3>
         
        <div3>
        <head>Children</head>
        <p>None.</p>
        </div3>
      </div2>
      
<div2 id="script"> 
      <head>&lt;script&gt; </head>
               <p>[This section is  normative.]</p>		
      <p>The &lt;script&gt; element adds scripting capability to the state machine.  
</p>

      <div3>
      <head>Attribute Details</head>
        <xi:include href="attributes/script.xml.html"/>
      </div3>
      <div3>
         <head>Children </head>
<p>The child content of the &lt;script&gt; element represents the script code to be executed.</p>
      </div3>
      <p>A conformant SCXML document <rfc2119>must</rfc2119> specify either the 'src' attribute
      or child content, but not both.  If 'src' is specified, the SCXML Processor
      <rfc2119>must</rfc2119> download the script from
      the specified location at load time.  If the script can not be downloaded within a 
      platform-specific timeout interval, the document is considered non-conformant, and the 
      platform <rfc2119>must</rfc2119> reject it.  
      </p>
      
 <p> The SCXML Processor <rfc2119>must</rfc2119> evaluate any &lt;script&gt; element that is a 
 child of &lt;scxml&gt; at document load time.  It <rfc2119>must</rfc2119> evaluate 
	all other &lt;script&gt; elements as part of normal executable content evaluation.
	</p>
	
<p>In a conformant SCXML document, the name of any script
	variable <rfc2119>may</rfc2119> be used as a location expression (see <specref ref="LocationExpressions"/>).</p>
	
	<p>For an example of a data model incorporating scripting, see <specref ref="ecma-profile"/>.
</p>

      </div2>
      
<div2 id="Expressions">
<head>Expressions</head>
         <p>[This section is  normative.]</p>		
<p>SCXML contains three types of expressions, as described below.  Different data models
	 will support different languages for these expression types, but certain properties
of the expressions are constant across languages and are defined here. </p>
<p>When &quot;late&quot; data binding is used, accessing data substructure in expressions before the 
	corresponding &lt;data&gt; element is loaded <rfc2119>must</rfc2119> yield the same execution-time behavior as accessing non-existent 
	data substructure in a loaded &lt;data&gt; instance. 	Such behavior is defined by the data expression 
	language in use.</p>
    
    <div3 id="ConditionalExpressions">
    <head>Conditional Expressions</head>
    <p>Conditional expressions are used inside the 'cond' attribute of &lt;transition&gt;,
&lt;if&gt; and &lt;elseif&gt;.    If 
a conditional expression cannot be evaluated as a boolean value ('true' or 'false') or if its evaluation
causes an error, the SCXML Processor <rfc2119>must</rfc2119> treat the expression as if it 
evaluated to 'false' and <rfc2119>must</rfc2119> place the
error 'error.execution' in the internal event queue.  The set of operators in conditional expressions
varies depending on the data model, but all data models <rfc2119>must</rfc2119> support the 'In()' predicate,
which takes a state ID as its argument and returns true if the state machine is in that state.  
This predicate allows coordination among parallel regions.  Conditional
expressions in conformant SCXML documents <rfc2119>should not</rfc2119> have side effects.</p>
</div3>
<div3 id="LocationExpressions">
<head>Location Expressions</head>
<p>Location expressions are used to specify a location in the data model, e.g. as part 
of the &lt;assign&gt;, &lt;param&gt;, &lt;send&gt; or &lt;invoke&gt; elements.  The exact nature of a location depends on the data model.  
 If a location expression
cannot be evaluated to yield a valid location, the SCXML processor
<rfc2119>must</rfc2119> place the error 'error.execution' in the internal event queue. </p>
</div3>
<div3 id="ValueExpressions">
<head>Legal Data Values and Value Expressions</head>
<p>A data model definition contains a specification of the underlying data structure.
 Such a specification
of the data structure implicitly defines a set of "legal
data values", namely the objects that can be part of such a data structure.  In conjunction with this, the data model definition specifies a set of value expressions
which can be evaluated at runtime to return legal data values.   If a value expression does not
return a legal data value, the SCXML Processor <rfc2119>must</rfc2119> place the error 'error.execution' 
in the internal event queue.
</p>
</div3>
<div3 id="ErrorsinExpressions">
<head>Errors in Expressions</head>
<p> The SCXML Processor <rfc2119>may</rfc2119> reject documents containing syntactically ill-formed expressions 
at document load time, or
it <rfc2119>may</rfc2119> wait and place 'error.execution' in the internal event queue at runtime when the expressions are evaluated.  
If the processor waits until it evaluates the expressions at runtime to raise errors, it
<rfc2119>must</rfc2119> raise errors caused by expressions returning illegal values at the points at which the 
expressions are to be evaluated.  Note that this requirement holds even if the implementation is optimizing
expression evaluation.  </p>
</div3>
</div2> 
            
<div2 id="SystemVariables">
    <head>System Variables</head>
             <p>[This section is  normative.]</p>		
    <p> The SCXML Processor <rfc2119>must</rfc2119> maintain a protected portion of the data model 
    containing information that can be useful to applications.  
    We refer to the items in this special part
    of the data model as 'system variables'.   Implementations <rfc2119>must</rfc2119> provide the following system
    variables, and <rfc2119>may</rfc2119> support others.  </p>
    <ul>
     <item ><p><em>_event</em>.  The SCXML Processor <rfc2119>must</rfc2119> use the
     variable '_event' to hold 
         a structure containing the current event's name and any data contained in the event (see
         <specref ref="InternalStructureofEvents"/>.         
         The exact nature of the structure depends on the data model being used.  See <specref ref="profiles"/> for details.
        The SCXML Processor <rfc2119>must</rfc2119> bind the  _event variable when an event is pulled 
        off the internal or external event
        queue to be processed, and <rfc2119>must</rfc2119> keep the variable bound to that event 
        until another event is processed. 
        (It follows that when an application is testing the 'cond' attribute of a &lt;transition&gt; element
         that contains an 'event' attribute,
        _event will be bound to the event that the transition is being matched against. 
        If the transition is selected to be executed,
        	_event will remain bound to that event in the &lt;onexit&gt; handlers of the states being exited,
        	the executable content of the transition itself, and the &lt;onentry&gt; 
        handlers of the states being entered.  In the case
         of &lt;transition&gt; elements that do not contain an 'event' attribute and the &lt;onexit&gt;
         and &lt;onentry&gt; handlers of any states that are exited or entered by such transitions, the
         _event variable will not have a easily predictable value since the transition is not being driven by
         an event.  In these cases, _event will be bound to the last event that 
         was matched against a transition.)
        The SCXML Processor <rfc2119>must not</rfc2119> bind _event at initialization time 
        until the first event is processed.  Hence _event is unbound when the state machine starts up.
 
         </p>
         <p>If the data in the event is not
         a legal instance of the data model language, and the Processor cannot translate it into one,
         then the Processor <rfc2119>must</rfc2119>
         place the error 'error.execution' in the internal event queue at the point at which it attempts to bind _event.  In
         this case, the Processor <rfc2119>must</rfc2119> leave the event data part of the _event 
         structure unbound.  
         (Note that the event's name
         will still be available, however and that processing
         of both the original event and the error event will proceed as usual.)</p></item>
         
         <item><p><em>_sessionid</em>.  The SCXML Processor <rfc2119>must</rfc2119> bind the variable _sessionid 
           at load time to the system-generated id for the current SCXML session.  (This is of 
           type NMTOKEN.)  The Processor <rfc2119>must</rfc2119> keep the variable bound to this value
           until the session terminates.
         </p></item>
         <item><p><em>_name</em>.  The SCXML Processor <rfc2119>must</rfc2119> bind the variable _name 
           at load time to the value of the 'name' attribute of the &lt;scxml&gt; element.  The Processor 
           <rfc2119>must</rfc2119> keep the variable bound to this value
           until the session terminates.</p></item>
         <item><p><em>_ioprocessors</em>. The SCXML Processor <rfc2119>must</rfc2119> bind the 
         variable _ioprocessors
           to a set of values, one for each Event I/O Processor that it supports.  
           The syntax to access it depends on the data model.  See <specref ref="profiles"/> for details.
           The nature of the values associated with the individual Event I/O Processors depends on the Event I/O
           Processor in question.  See <specref ref="eventioprocessors"/> for details. 
           The Processor <rfc2119>must</rfc2119> keep the variable bound to this set of values
           until the session terminates.
           </p></item>
         <item><p><em>_x</em>. The variable _x is the root element for platform-specific system
          variables.  The Processor <rfc2119>must</rfc2119> place all platform-specific system 
          variables underneath it. The exact structure of the platform-specific variables
          depends on the data model. For example, in the ECMAScript data model <specref ref="ecma-profile"/>, 
          '_x' will be a top-level ECMAScript object and the platform-specific system variables 
          will be its properties. 
         </p></item>
         </ul>
         <p> The set of system variables may be expanded in future versions of this specification. 
         	Variable names beginning with '_' are reserved for system use. 
         	 A conformant SCXML document 
         	<rfc2119>must not</rfc2119>  contain ids beginning with '_' in the &lt;data&gt; element.
         	Platforms <rfc2119>must</rfc2119> place all platform-specific system variables under
         	the '_x' root.  </p>
         <p>The concrete realization of these variables in a specific
    data model depends on the language used.    The Processor <rfc2119>must</rfc2119> cause 
    any attempt to change the value of a system variable to fail 
    and <rfc2119>must</rfc2119> place the error 'error.execution' on the internal event queue when such an attempt is made.  </p>
    
    <div3 id="InternalStructureofEvents">
    	<head>The Internal Structure of Events</head>
    	<p>Events have an internal structure which is reflected in the _event variable.  This
    		variable can be accessed to condition transitions (via boolean
    		expressions in the 'cond' attribute) or to update the data model (via &lt;assign&gt;), etc. 
    		</p>
    		<p>
    		The SCXML Processor <rfc2119>must</rfc2119> ensure that the following fields are present 
    		in all events, whether internal or external. 
    		</p>
    		<ul>
    			<item><em>name</em>.  This is a character string giving the name of the event.  The
    			SCXML Processor <rfc2119>must</rfc2119> set the name field to the name of this event.  It
    			is what is matched against the 'event' attribute of &lt;transition&gt;.  Note that 
    			transitions can do additional tests by using the value of this field 
    			inside boolean expressions in the 'cond' attribute.</item>
    			<item><em>type</em>.  This field describes the event type.  The
    			SCXML Processor <rfc2119>must</rfc2119> set it to: "platform" (for events raised
    			by the platform itself, such as error events),  "internal" (for events raised by
    			&lt;raise&gt; and &lt;send&gt; with target '_internal') or "external" (for all other events).</item>
    			<item><em>sendid</em>.  If the sending entity has specified a value for this, the Processor
    			<rfc2119>must</rfc2119> set this field to that value (see <specref ref="eventioprocessors"/> for details).  Otherwise, in the case of error events triggered by a failed attempt to
    			send an event, the Processor <rfc2119>must</rfc2119> set this field to the send id of the triggering &lt;send&gt; element.
    			Otherwise it <rfc2119>must</rfc2119> leave it blank.</item>
    			<item><em>origin</em>.  This is a URI, equivalent to the 'target' attribute on the 
    			&lt;send&gt; element.  For external events,
    			the SCXML Processor 
    			<rfc2119>should</rfc2119> set this field to a value which, when used as the value of 'target',
    		  will allow the receiver of the event to &lt;send&gt; a 
    			response back to the originating entity via the Event I/O Processor specified in 'origintype'.
    		 For internal and platform events, the Processor <rfc2119>must</rfc2119> leave this field blank. </item>
    			<item><em>origintype</em>.  This is equivalent to the 'type' field on the &lt;send&gt; element.  
    			For external events,
    			the SCXML Processor 
    			<rfc2119>should</rfc2119> set this field to a value which, when used as the value of 'type', 
    			will allow the receiver of the event to &lt;send&gt; a 
    			response back to the originating entity at the URI specified by 'origin'.  For internal and platform events, the Processor <rfc2119>must</rfc2119> leave this field blank.</item>
     			<item><em>invokeid</em>.  If this event is generated from an invoked child process, the
     			SCXML Processor <rfc2119>must</rfc2119> set this
     			field to the invoke id of the invocation that triggered the child process.  Otherwise
     			it <rfc2119>must</rfc2119> leave it blank.</item>
    			<item><em>data</em>.  This field contains whatever data the sending entity chose to include
    			in this event.  The receiving SCXML Processor <rfc2119>should</rfc2119> reformat this data to 
    			match its data model, but
    			<rfc2119>must not</rfc2119> otherwise modify it.  If the conversion is not possible,
    		    the Processor <rfc2119>must</rfc2119> leave the field blank and <rfc2119>MUST</rfc2119> 
    		    place an error 'error.execution' in the internal event queue.</item>
    		</ul>

    		</div3>
    </div2>
    </div1>
<div1 id="external-module">
<head>External Communications</head>
<div2 id="ExternalIntroduction">
	<head>Introduction</head>
	<p>[This section is informative.]</p>
<p>The External Communications capability allows an SCXML session to send and receive events
from external entities, and to invoke external services.  <specref ref="send"/> provides "fire and forget"
	capability to deliver events and data to any destination, including other SCXML sessions.  The
	'delay' attribute allows for deferred event delivery and can be used to implement a timer.  The details
	of event transport as well as the format of the event and data are determined by the Event I/O Processor
	selected.  Each implementation will support one or more such processor, and the author of the SCXML
	markup can choose the one that is appropriate for the type of endpoint he is trying to reach.</p>
	<p>  <specref	ref="invoke"/> offers a more tightly coupled form of communication, specifically the ability to 
		trigger a platform-defined service and pass data to it.  It and its child &lt;finalize&gt; are 
		useful in states
            that model the behavior of an external service.  The &lt;invoke&gt; element is executed 
            after the state's &lt;onentry&gt; element and causes an instance of the external service
            to be created. 
            The &lt;param&gt; and &lt;content&gt; elements and the 'namelist' attribute can be used to pass data to the service.  
            Any events that are received by the state machine from the invoked component 
            during the invocation are preprocessed by the &lt;finalize&gt; handler <em>before</em> 
            transitions are selected.  The &lt;finalize&gt;
            code is used to normalize the form of the returned data and to update the data model before
            the transitions' "event" and "cond" clauses are evaluated. 	
	</p>
	         <p> When parallel states invoke the same external service concurrently, separate
instances of the external service will be started.  They can be distinguished by ids which are associated
with them. Similarly, the 
        ids contained in the events returned from the external services can be used to determine
         which events are responses to which invocation.  Each event that is returned will be
         processed only by the &lt;finalize&gt; in the state that invoked it, but that event
         is then processed like any other event that the state machine receives.  The finalize
         code can thus be thought of as a preprocessing stage that applies before the event is added to the
         event queue.  Note that the event will be passed to all parallel states to check for
         transitions.  </p> 

            <p>Since an invocation will be canceled when the state machine
            	leaves the invoking state, it does not make sense to start an invocation in a state
            	that will be exited immediately.  Therefore the &lt;invoke&gt; element
            is executed upon entry into the state, but only <em>after</em> checking for 
            eventless transitions and transitions driven by pending internal events.   If any
            such enabled transition is found , it is taken and the state is exited immediately, 
            without triggering the invocation.  Thus invocations are triggered only when the
            state machine has reached a stable configuration, i.e., one that it will be staying
            in while it waits for external events.  </p>        
</div2>

        <div2 id="send">
          <head>&lt;send&gt;</head>		
              <p>[This section is  normative.]</p>		     
          <div3>
            <head>Overview</head>
            
            <p>&lt;send&gt; is used to send events and data to external systems, including external
            SCXML Interpreters,  or to raise events in the current SCXML session.   </p>
            
            
           
 
          </div3>
 
          
          <div3>
            <head>Attribute Details</head>
            <xi:include href="attributes/send.xml.html"/>
          </div3>


       <div3>
          <head>Children</head>
          <ulist> 
          <item><p>&lt;param&gt;.  The SCXML Processor <rfc2119>must</rfc2119> evaluate
          this element when the parent &lt;send&gt; element is evaluated and pass the resulting data 
          to the external service when the message is delivered.  Occurs 0 or more times.  See <specref ref="param"/> for details.
      
           </p></item>
          <item><p>&lt;content&gt;.  The SCXML Processor <rfc2119>must</rfc2119> evaluate
          this element when the parent &lt;send&gt; element is evaluated and pass the resulting data 
          to the external service when the message is delivered.   Occurs 0 or 1 times. 
          See <specref ref="content"/> for details.  
            </p></item>
          </ulist>
 <p>A conformant SCXML document <rfc2119>must</rfc2119> specify exactly one of  'event', 'eventexpr' and 
 &lt;content&gt;.  A conformant document  <rfc2119>must not</rfc2119> specify  "namelist" or &lt;param&gt;
          with &lt;content&gt;. </p>
          
 <p>The SCXML Processor <rfc2119>must</rfc2119> include all attributes and values provided
          by &lt;param&gt; or 'namelist' even if duplicates occur.    </p>
          
          <p>If 'idlocation' is present, the SCXML Processor <rfc2119>must</rfc2119> 
					generate an id when the parent &lt;send&gt; element is evaluated and store it in this location.
					See <specref ref="IDs"/> for details. 
					</p>
 <p>
 	If a delay is specified via 'delay' or 'delayexpr', the SCXML Processor <rfc2119>must</rfc2119> 
 	interpret the character string as a time interval.
					It <rfc2119>must</rfc2119> dispatch the message only when the delay interval
					elapses. (Note that the evaluation of the <code>send</code> tag will return immediately.)
					  The Processor <rfc2119>must</rfc2119> evaluate all arguments to &lt;send&gt; 
					when the &lt;send&gt; element is evaluated, and not when 
					the message is actually dispatched. If the 
					evaluation of &lt;send&gt;'s arguments produces an error, the Processor 
					<rfc2119>must</rfc2119> discard the message without attempting to deliver it.  If the SCXML session terminates before the delay interval has elapsed, the SCXML Processor
					<rfc2119>must</rfc2119> discard the message without attempting to deliver it.  </p>         
          
 
       </div3>
                <div3 id="SendTargets">
          <head>The Target of Send</head>
           <p>The target of the &lt;send&gt; operation specifies the destination of the 
           	event.  The target is defined by either the 'target' or the 'targetexpr' 
           	attribute. In most cases, the format of the target depends on the type of the target
            (for example a SIP URL for SIP-INFO messages or a HTTP
            URL for Web Services). 
            
            If the value of the 'target' or 'targetexpr' attribute is not supported or invalid,
            the Processor <rfc2119>must</rfc2119> place the error error.execution on the 
            internal event queue.  If it is unable to dispatch the message, the Processor <rfc2119>must</rfc2119> place the 
            error error.communication on the internal event queue.</p>
            </div3>
       <div3 id="SendTypes">
       	<head>The Type of Send</head>
             
            <p>The type of the &lt;send&gt; operation specifies the method that the
            	SCXML processor <rfc2119>must</rfc2119> use to deliver the message to its target.  
            	A conformant SCXML document <rfc2119>may</rfc2119> use either 
            	the 'type' or the 'typeexpr' attribute to define the type.  
            If neither the 'type' nor the 'typeexpr' is defined, the SCXML Processor
            <rfc2119>must</rfc2119> assume the default value of http://www.w3.org/TR/scxml/#SCXMLEventProcessor. 
            If the SCXML Processor does not support the type that is specified, it <rfc2119>must</rfc2119>
             place the event error.execution on the internal event queue.</p>
            
            <p>SCXML Processors  <rfc2119>must</rfc2119> support the following type:</p>
            
            <table cellpadding="2" cellspacing="2" border="1" width="100%" summary="send type values">
              <tbody>
               <tr>
                  <th align="center" rowspan="1" colspan="1">Value</th>
                  
                  <th align="center" rowspan="1" colspan="1">Details</th>
                </tr>
                
                <tr>
                  <td align="center" rowspan="1" colspan="1">http://www.w3.org/TR/scxml/#SCXMLEventProcessor</td>                  
                  <td align="left" rowspan="1" colspan="1">Target is an SCXML session.  The transport
                  	mechanism is platform-specific. </td>
                </tr>
               </tbody>
            </table>

            <p>For details on the http://www.w3.org/TR/scxml/#SCXMLEventProcessor type, see <specref ref="SCXMLEventProcessor"/>.</p>

             <p>Support for HTTP POST is optional, however Processors that support it
             <em>must</em> use the following value for the "type" attribute:</p>
            
            <table cellpadding="2" cellspacing="2" border="1" width="100%" summary="send type values">
              <tbody>
                <tr>
                  <th align="center" rowspan="1" colspan="1">Value</th>
                  
                  <th align="center" rowspan="1" colspan="1">Details</th>
                </tr>
                
                <tr>
                  <td align="center" rowspan="1" colspan="1">http://www.w3.org/TR/scxml/#BasicHTTPEventProcessor</td>                  
                  <td align="left" rowspan="1" colspan="1">Target is a URL.  Data is sent via HTTP POST</td>
                </tr>
               </tbody>
            </table>
            
            <p>For details on the http://www.w3.org/TR/scxml/#BasicHTTPEventProcessor type, see <specref ref="BasicHTTPEventProcessor"/>. 
</p>
 
         	
            	
<p>	Processors <rfc2119>may</rfc2119> support other types such as web-services, SIP or basic HTTP GET. 
When they do so, they <rfc2119>should</rfc2119> assign such types the URI of the description of the 
relevant Event I/O Processor.  Processors <rfc2119>may</rfc2119> define short form notations as
an authoring convenience (e.g., "scxml" as equivalent to http://www.w3.org/TR/scxml/#SCXMLEventProcessor).</p>
      	
       	
       	</div3>
            
            <div3 id="SendContent">
            	<head>Message Content</head>
            <p>The sending SCXML Interpreter <rfc2119>must</rfc2119> not alter the content of the
            &lt;send&gt; and <rfc2119>must</rfc2119> include it in the message that it
            sends to the destination specified in the target attribute of &lt;send&gt;. 
</p>
                      
            <p>Note that the document author can specify the message content  
            in one  of two 
            mutually exclusive ways:</p>
 <ulist>
 	<item><p>
                An optional 'event' attribute, combined with an optional 'namelist' attribute,
                 combined with 0 or more &lt;param&gt; children.  
                Here is an example using the 'event' and 'namelist' attributes:  
                <eg space="preserve" xml:space="preserve">
&lt;datamodel&gt;
&lt;data id="target" expr="'tel:+18005551212'"/&gt;
&lt;data id="content" expr="'http://www.example.com/mycontent.txt'"/&gt;
&lt;/datamodel&gt;
   ...
&lt;send target="target" type="x-messaging" event="fax.SEND" namelist="content"/&gt;</eg>
              </p></item>
              
              <item><p>
                A single &lt;content&gt; child containing inline content specifying 
                the message body.  See <specref ref="content"/> for details.
                <eg space="preserve" xml:space="preserve">
&lt;send target="csta://csta-server.example.com/" type="x-csta"&gt;
      &lt;content&gt;
      &lt;csta:MakeCall&gt;
        &lt;csta:callingDevice&gt;22343&lt;/callingDevice&gt;
        &lt;csta:calledDirectoryNumber&gt;18005551212&lt;/csta:calledDirectoryNumber&gt;
      &lt;/csta:MakeCall&gt;
      &lt;/content&gt;
&lt;/send&gt;</eg>
              </p></item>
              
            </ulist>
            
             


<p>  Note that the absence of any error events
            does not mean that the event was successfully delivered to its target, but only that the 
            platform was able to dispatch the event.</p>         	
           </div3>
        </div2>
        <div2 id="cancel">
        	<head>&lt;cancel&gt;</head>
        	         <p>[This section is  normative.]</p>		
        	<p>The &lt;cancel&gt; element is used to cancel a delayed &lt;send&gt; event. 
        		 The SCXML Processor <rfc2119>must not</rfc2119> allow &lt;cancel&gt; to
        		 affect events that were not raised in the	same session. The Processor
        		<rfc2119>should</rfc2119> make its best attempt to cancel all delayed events with the
        		specified id.   Note,
        		however, that it can not be guaranteed
        		to succeed, for example if the event has already been delivered by the time
        		the &lt;cancel&gt; tag executes.
        		</p>
        <div3>
          <head>Attribute Details</head>
          <xi:include href="attributes/cancel.xml.html"/>
        </div3>
 <p>A conformant SCXML document <rfc2119>must</rfc2119> specify exactly one of sendid or sendidexpr. </p>        
        <div3>
          <head>Children</head>
          <p>None</p>
          </div3>
          </div2>
        
                   <div2 id="invoke">
        <head>&lt;invoke&gt;</head>	
                 <p>[This section is  normative.]</p>			
        <p> The &lt;invoke&gt; element is used to create an instance of an external service.
         </p>

         

         

      <div3 id="invokeattrs">
          <head>Attribute Details</head>
          <xi:include href="attributes/invoke.xml.html"/>
 
          		
        </div3>
          
        <div3>
          <head>Children</head>
          <ulist> 
          <item><p>&lt;param&gt;.  Element containing data to be passed to the
          external service.  Occurs 0 or more times.  See <specref ref="param"/>. </p></item>
          <item><p>&lt;finalize&gt;.  Element containing executable content to 
          massage the data returned from the invoked component.  Occurs 0 or 1 times. 
          See <specref ref="finalize"/> for details.  
            </p></item>
         <item><p>&lt;content&gt;.  The SCXML Processor MUST evaluate this element when the parent &lt;invoke&gt; 
         	element is evaluated and
         	 pass the resulting data to the invoked service. Occurs 0 or 1 times. 
          See <specref ref="content"/> for details.  
            </p></item>
          </ulist>
  
       </div3>
                 <p>          Platforms <rfc2119>must</rfc2119> support http://www.w3.org/TR/scxml/ as a value for
           the 'type' attribute.  Platforms <rfc2119>may</rfc2119> support http://www.w3.org/TR/voicexml21/, which
          indicates a VoiceXML 2.1 interpreter, http://www.w3.org/TR/voicexml30/, which indicates a VoiceXML 3.x interpreter,
          and http://www.w3.org/TR/ccxml/, which indicates a CCXML 1.0 interpreter.  
          Platforms <rfc2119>may</rfc2119> support additional values, but they <rfc2119>should</rfc2119> 
          assign them the URI of a description of the relevant service.    Processors <rfc2119>may</rfc2119> define short form notations as
an authoring convenience (e.g., "scxml" as equivalent to http://www.w3.org/TR/scxml/).
          </p>
          <p>A conformant SCXML document <rfc2119>may</rfc2119> specify either the 'id' or 'idlocation' 
          attribute, but <rfc2119>must not</rfc2119> specify both. 
          	If the  'idlocation' attribute is present, the SCXML Processor <rfc2119>must</rfc2119>
          	generate an id automatically when the &lt;invoke&gt; element is evaluated and store it in the location 
          	specified by 'idlocation'.  (In the rest of this document, we will
          	refer to this identifier as the "invokeid", regardless of whether it is specified by the
          	author or generated by the platform).  
					The automatically generated identifier <rfc2119>must</rfc2119> have the form
					<em>stateid.platformid</em>, where <em>stateid</em> is the id of the state containing
					this element and <em>platformid</em> is automatically generated.  <em>platformid</em>
					<rfc2119>must</rfc2119> be unique within the current session.</p>

                <p>When the &lt;invoke&gt; element is executed, if the evaluation of its
             arguments produces an error, the SCXML Processor <rfc2119>must</rfc2119> terminate
             the processing of the element without further action.  
             Otherwise the Processor <rfc2119>must</rfc2119> start
         a new logical instance of the external service specified in 'type' or 'typeexpr', passing it the
         URL specified by 'src' or the data specified by &lt;content&gt;, "namelist" or &lt;param&gt;.  (Note that
         the invoked service may ignore some or all of the data passed to it.  See <specref ref="invokeimplementation"/> 
         for a discussion of how the passed data is treated by an invoked SCXML service.) The service
         instance <rfc2119>may</rfc2119> be local or remote.  In addition to the explicit arguments, 
         the Processor
         <rfc2119>must</rfc2119> keep track of the unique invokeid and ensure that it is included 
         in all events 
         that the invoked service returns to the invoking session. </p>
           	<p>When the 'autoforward' attribute is set to true, the SCXML Processor <rfc2119>must</rfc2119> send
          		an exact copy of every external event it receives to the invoked process.  
          		All the fields specified in <specref ref="InternalStructureofEvents"/> <rfc2119>must</rfc2119>
          		 have the same values in the forwarded copy of the event.  The SCXML Processor 
          		 <rfc2119>must</rfc2119> forward the event at the point at which it removes it from
          		 the external event queue of the invoking session for processing.  </p>
         <p> The external service <rfc2119>may</rfc2119> return
         multiple events while it is processing.  If there is a &lt;finalize&gt; handler in the 
         instance of &lt;invoke&gt; that created the service that generated the event,
         the SCXML Processor <rfc2119>must</rfc2119> execute the code
         in that &lt;finalize&gt; handler right before it removes the event from
         the event queue for processing.  It <rfc2119>must not</rfc2119> execute the &lt;finalize&gt; handler in
         any other instance of &lt;invoke&gt;.  Once the external service has finished processing it 
         <rfc2119>must</rfc2119> return a special event 'done.invoke.<em>id</em>' to the 
         external event queue of the invoking process, where <em>id</em> is the invokeid
         for the corresponding &lt;invoke&gt; element. 
         The external service <rfc2119>must not</rfc2119>  generate any other events after this done event. 
         If the invoking
         session takes a transition out of the state containing the &lt;invoke&gt; before it
         receives the 'done.invoke.<em>id</em>' event, the SCXML Processor 
         <rfc2119>must</rfc2119> automatically cancel the invoked 
         component and stop its processing.  The cancel operation <rfc2119>must</rfc2119> act as if it 
         were the final
         &lt;onexit&gt; handler in the invoking state.  </p>
         <p>Invoked services of type http://www.w3.org/TR/scxml/, http://www.w3.org/TR/ccxml/, 
http://www.w3.org/TR/voicexml30/, or http://www.w3.org/TR/voicexml21/
 <rfc2119>must</rfc2119>
         interpret values specified by 
       the &lt;content&gt; element or 'src' attribute as markup to be executed.
       Similarly, they <rfc2119>must</rfc2119> interpret values
       specified by &lt;param&gt; element or  'namelist' attribute as
       values that are to be injected into their data models. 
       For targets of other invoked service types, the interpretation of &lt;param&gt; 
       and &lt;content&gt; elements and the 'src' and 'namelist' attributes is platform-specific.  
       However, these services <rfc2119>must</rfc2119> treat values specified by
       &lt;param&gt; and namelist identically. They <rfc2119>must</rfc2119> also treat values 
       specified by 'src' and &lt;content&gt; identically.</p>


       <div3 id="invokeimplementation">
       <head>Implementation of &lt;invoke&gt;</head>
       <p>The implementation of &lt;invoke&gt;, including communication between 
       	parent and child processes, is platform-specific, but the following requirements
       hold in the case where the invoked process is itself an SCXML session:       
       </p>
       <ul>
       <li>If the 'name' of a &lt;param&gt; element in the &lt;invoke&gt; matches the 'id' of a
       &lt;data&gt; element in the top-level data declarations of the invoked session, the
       SCXML Processor <rfc2119>must</rfc2119> use the value of the 
       &lt;param&gt; element as the initial value of the corresponding &lt;data&gt; element.  (The top-level 
       data declarations are those that are contained in the &lt;datamodel&gt; element that is a child of &lt;scxml&gt;.)
       (Note that this means that any value specified in the &lt;data&gt; element is ignored.)  
       The behavior of 'namelist' is similar.  If the value of a key in the namelist matches the 'id'
       of a &lt;data&gt; element in the top-level data model of the invoked session, the
       SCXML Processor <rfc2119>must</rfc2119> use the value of the 
       key as the initial value of the corresponding &lt;data&gt; element.
       If the names do not match, the Processor <rfc2119>must not</rfc2119> add
       the value of the &lt;param&gt; element or namelist key/value pair to
       the invoked
       session's data model.  However the Processor <rfc2119>may</rfc2119> make the values available 
       by some other platform-specific means.</li>
       <li>When the invoked state machine reaches a top-level final state, the Processor
       	<rfc2119>must</rfc2119> place the event
       done.invoke.<em>id</em> on the external event queue of the invoking machine, where <em>id</em> is
       the invokeid for this invocation.  Note that reaching a top level final
       state corresponds to normal termination of the machine and that it cannot generate or process
       any further events once it is in this state.
       </li>
       <li>As described above, if the invoking state machine exits the state containing the invocation 
       	before it receives
       the done.invoke.<em>id</em> event, it cancels the invoked session.  The method for doing
       this is platform-specific.  However, when it is cancelled, the 
       invoked session <rfc2119>must</rfc2119> exit at the end of the next microstep. The Processor <rfc2119>must</rfc2119> execute
       the &lt;onexit&gt; handlers for all active states in the invoked session, but it <rfc2119>must not</rfc2119> 
       generate the done.invoke.<em>id</em> event. 
       Once it cancels the invoked session, the Processor <rfc2119>must</rfc2119> ignore any 
       events it receives
       from that session.  In particular it <rfc2119>must not</rfc2119> not insert them into the external event
       queue of the invoking session.
       </li>
       <li>The SCXML Processor <rfc2119>must</rfc2119> support the use of SCXML Event/IO processor 
       (<specref ref="SCXMLEventProcessor"/>) 
       to communicate between the invoking and the invoked sessions.  
       The Processor <rfc2119>may</rfc2119> support the use of other Event/IO processors 
       to communicate between the invoking and the invoked sessions.</li>
       </ul>
       
       </div3>
              <div3 id="DataSharing">
       <head>Data Sharing</head>
       <p>[This section is informative.]</p>
       <p>The invoked external resource is logically separate from the state machine 
       that invokes it and does not share data with it unless the author explicitly requests
       this with the &lt;param&gt; or &lt;content&gt; elements and/or
       the 'src' and 'namelist' attributes.</p>
       <p>
The invoked and invoking process can also communicate via events.  
In addition to automatic forwarding specified by the 'autoforward' attribute. 
       SCXML scripts can also use the &lt;send&gt; tag to send messages to the child process on 
       an ad-hoc basis.  The 'type' attribute of  &lt;send&gt; is set to the same
       value as was used in the original &lt;invoke&gt;, while the target has the special
       form #_<em>invokeid</em>, where <em>invokeid</em> is the identifier corresponding to the original
       &lt;invoke&gt; tag.
         For example, in a document using ECMAScript as the data model, the following code would invoke
       a VoiceXML session:</p>  
       <eg xml:space="preserve">
  &lt;invoke type="http://www.w3.org/TR/voicexml21/" idlocation="myInvoke"/&gt;
       </eg>
       <p>
       	In this case, the unique invoke identifier has been  stored in the data model location MyInvoke. 
       	Since the target attribute is an expression which is evaluated, the following code will extract
       	that identifier and send a message to the invoked VoiceXML session:
       	</p>
       <eg xml:space="preserve">       	
  &lt;send type="http://www.w3.org/TR/voicexml21/" targetexpr="'#_' + myInvoke"/&gt;
       		</eg>
       
       <p>
       Finally, in the case where the invoked external service is an SCXML session, it 
       can use &lt;send&gt; with the special target '_parent' and type 'scxml' to send events, 
       possibly containing data, to the invoking session.   </p>
  
       
       </div3>
       </div2>
       

     
    <div2 id="finalize"> 

      <head>&lt;finalize&gt; </head>
               <p>[This section is  normative.]</p>		
      <p>The &lt;finalize&gt; element enables an invoking session to update
      	its data model with data contained in events returned by the invoked session.
      	        &lt;finalize&gt; contains executable
        content that is executed whenever the external service returns an event 
        after the &lt;invoke&gt; has 
        been executed.  This content is applied before the system looks for transitions
        that match the event.  Within
        the executable content, the system variable '_event' can be used to 
        refer to the data contained
        in the event which is being processed.In the case of parallel states, only the finalize code in the 
        original invoking state is executed. </p>
      <div3>
      <head>Attribute Details</head>
      <p>None.</p>
      </div3>
      <div3>
         <head>Children </head>
               <p>
        &lt;finalize&gt;'s children consist of 0 or more elements of executable content.  </p>
        	 </div3>  
        <p>
 In a conformant SCXML document, the executable content inside &lt;finalize&gt; 
 <rfc2119>must not</rfc2119> raise events or invoke external 
            actions.  In particular, the &lt;send&gt; and &lt;raise&gt; elements  
            <rfc2119>must not</rfc2119> occur.
            </p>
  <p>If one or more elements of executable content is specified, the SCXML Processor  <rfc2119>must</rfc2119>
  execute them each time an event is received from the child process that was created by the parent &lt;invoke&gt;
  element.  The Processor <rfc2119>must</rfc2119>
  execute them right before the event is pulled off the external event queue for processing.  The Processor
  <rfc2119>must not</rfc2119> execute them at any other time or in response to any other events.  
  </p>
  
        <p>If no executable content is specified, the SCXML Processor  <rfc2119>must</rfc2119>
  update the data model each time an event is received from the child process that was created by the parent &lt;invoke&gt;
  element.  Specifically if the parent &lt;invoke&gt;
  element contains a 'namelist' attribute or one or more &lt;param&gt; children containing 'location' attributes,
  then for each item in the 'namelist' attribute and each such &lt;param&gt; element, the Processor <rfc2119>must</rfc2119> 
        update the corresponding location as if by &lt;assign&gt; with any return value that has a name that matches the 
        'namelist' item or the 'name' of the &lt;param&gt;
  element.  Thus the effect of an &lt;invoke&gt; with an empty &lt;finalize&gt; element and either a 'namelist' 
         attribute or a &lt;param&gt; element with
        a 'location' attribute is first to send the part of the data model specified by 'namelist' or 'location' 
         to the invoked component 
        and then to update
        that part of the data model with any returned values that have the same name. Note that the automatic
        update does not take place if the &lt;finalize&gt; element is absent as opposed to empty. </p>  
               

<p>In the example below, a state machine using an ECMAScript data model
	invokes a clock object that returns the current time
in a ping event with an XML payload that includes the
currentSecond, currentMinute, currentHour (1-12), and an isAm flag.  
&lt;finalize&gt; maps this data into an ECMAScript date object that is used 
in the condition of a transition.  Thus &lt;finalize&gt; normalizes the data 
before the conditions on transitions are evaluated.
</p>
<eg xml:space="preserve"><![CDATA[
<scxml version="1.0" datamodel="ecmascript">
....
 <state id=”getTime”>
   <transition event=”ping” cond=”time.getHours() > 17 || time.getHours() < 9” target=”storeClosed”/>
   <transition event=”ping” target=”takeOrder”/>
   <datamodel>
     <data id=”time” expr=”new Date()”/>
   </datamodel>
   <invoke id=”timer” type=”x-clock” src=”clock.pl”>
     <finalize>
       <script>
         time.setSeconds(_event.data.currentSecond);
         time.setMinutes(_event.data.currentMinute);
         time.setHours(_event.data.currentHour + (_event.isAm ? 0 : 12) - 1);
       </script>
     </finalize>
   </invoke>
 </state>
....
]]>
</eg>


</div2>
        
</div1> 

 
</body>

  <!-- 
       -
       -	SCXML Appendix section 
       -
  -->

  <back>
    

<div1 id="conformance">
<head>Conformance</head>
         <p>[This section is  normative.]</p>		
<div2 id="ConformingDocuments">
	<head>Conforming Documents</head>
<p>The following conformance requirements hold for all SCXML documents.  
	</p>  
	<olist>
		<li>The root element of the document <rfc2119>must</rfc2119> be &lt;scxml&gt;.</li>
		<li>The &lt;scxml&gt; element <rfc2119>must</rfc2119> include a "version" attribute with the value "1.0".</li>
		<li>The &lt;scxml&gt; element <rfc2119>must</rfc2119> designate the SCXML namespace. 
			This can be achieved by declaring an "xmlns" attribute or an attribute with an "xmlns" prefix 
			<bibref ref="XMLNames"/>. The namespace for SCXML is defined to be http://www.w3.org/2005/07/scxml.</li>
			<li>The document <rfc2119>must</rfc2119> conform to all the syntactic constraints defined in this specification, including
				those contained in the schema, those contained in the "Attribute Constraints" and "Valid Values"
				fields in the attribute tables, and those contained in the definition of its children.</li>
		<li>The document <rfc2119>must</rfc2119> conform to any additional syntactic constraints that are defined for the
			data model that it has chosen. See <specref ref="profiles"/> for
	the definition of the individual data models.  </li>
		
		</olist>

	

</div2>

<div2 id="ConformingProcessors">
	<head>Conforming Processors</head>
<p>A SCXML 1.0 processor is a user agent that can parse and process Conforming SCXML 1.0
 documents.</p>

<p>In a Conforming SCXML 1.0 Processor, the XML parser <rfc2119>must</rfc2119> be able to parse and 
process all well-formed XML constructs defined within <bibref ref="XML"/> and 
<bibref ref="XMLNames"/>. 
It is not required that a Conforming SCXML 1.0 processor use a validating parser.</p>     

<p>A Conforming SCXML 1.0 Processor 
<rfc2119>must</rfc2119> support the syntax and semantics of all 
mandatory SCXML elements described in this document. A Conforming SCXML 1.0 Processor 
<rfc2119>may</rfc2119> support the syntax and semantics of any 
optional SCXML elements described in this document.  
</p>
<p>When a Conforming SCXML 1.0 Processor encounters a non-conformant document, or
one containing non-SCXML elements or attributes which are proprietary, 
or defined in a non-SCXML namespace, its behavior is undefined.</p>

<p>
There is no conformance requirement with respect to performance 
characteristics of the SCXML 1.0 Processor. </p>  
</div2>
</div1>

<div1 id="profiles">
<head>Data Models</head>
         <p>[This section is  normative.]</p>		
<p>The 'datamodel' attribute on &lt;scxml&gt; defines the data model that the document
	uses.  The data model includes the underlying data structure plus languages for boolean expressions,
	 location expressions, value expressions, and scripting.  A conformant SCXML document
	<rfc2119>may</rfc2119> specify the data model it uses.  Conformant SCXML processors 	<rfc2119>must</rfc2119> support the null data model,
	and <rfc2119>may</rfc2119> support other data models, including the ECMAScript
	and XPath data models.  The ECMAScript and XPath model definitions given here
	are normative in the sense that they define how implementations that support one of these languages
	 <rfc2119>must</rfc2119> behave.  The intent is to ensure interoperability among all processors
	 that support ECMAScript, and all those that support XPath, without requiring all 
	 implementations to support either of those	data model languages. 
	</p>
	
	
<p>The definition of a data model <rfc2119>must</rfc2119>: </p>
<ul>
<li>Specify the boolean expression language used as the value of the 'cond' attribute in
&lt;transition&gt;, &lt;if&gt; and &lt;elseif&gt;  This language <rfc2119>must</rfc2119> not have side effects
and <rfc2119>must</rfc2119> include the 
predicate 'In', which takes a single argument, the id of a state in the enclosing
state machine, and returns 'true' if the state machine is in that state.</li>

<li>Specify the location expression language that
is used as the value of the 'location' attribute of the &lt;assign&gt; tag.  </li>
<li>Specify the value expression language that is used as the value of the 'expr' attribute of the
&lt;data&gt; and &lt;assign&gt; elements.</li>
<li>Specify the scripting language used inside the &lt;script&gt; element</li>
</ul>



<div2 id="minimal-profile">
<head>The Null Data Model</head>


<p>The value "null" for the 'datamodel' attribute results in an absent or empty data model.  In particular: </p> 
<div3>
<head>Data Model</head>
<p>There is no underlying data model.</p>
</div3>
<div3>
<head>Conditional Expressions</head>
<p>The boolean expression language consists of the In predicate <em>only</em>.  It has the 
form 'In(<em>id</em>)', where <em>id</em> is the id of a state in the enclosing state machine.  The predicate
<rfc2119>must</rfc2119> return 'true' if and only if that state is in the current state configuration.  
</p>
</div3>
<div3>
<head>Location Expressions</head>
<p>There is no location expression language.   </p>
</div3>
<div3>

<head>Value Expressions </head>
<p>There is no value expression language. </p>
</div3>
<div3>

<head>Scripting</head>
<p>There is no scripting language.  </p>
</div3>
<div3>

<head>System Variables</head>
<p>System variables are not accessible.</p>

</div3>
<div3>
	<head>Unsupported Elements</head>
<p>The &lt;foreach&gt; element and the elements defined in <specref ref="data-module"/> are 
	not supported in the 
	Null Data Model. 
	</p>
	</div3>
</div2>
<div2 id="ecma-profile">
<head>The ECMAScript Data Model</head>

<p>The value 'ecmascript' for the 'datamodel' attribute results in an
	ECMAScript data model.  Implementations that support this  value <rfc2119>must</rfc2119> support the third edition of
ECMAScript <bibref ref="ECMAScript262"/>.  Implementations
<rfc2119>may</rfc2119> support JSON <bibref ref="JSON"/> or ECMAScript for XML (E4X) <bibref
ref="E4X"/>.</p>


<div3 id="ecma_core_module">
<head>Data Model</head>
<p>For each &lt;data&gt; element in the document, the SCXML Processor <rfc2119>must</rfc2119> create 
 an ECMAScript variable object whose name is the value of the 'id' attribute of
<code>&lt;data></code>. In cases where the 'src' attribute or in-line content is 
provided in the &lt;data&gt; element, then if an indication of the type of the content
is available (e.g., via a Content-Type header), then the Processor <rfc2119>should</rfc2119>
 try to interpret the content according to that indication. 
Otherwise if the content (whether fetched or provided
in-line) is JSON (and the Processor supports JSON), the SCXML Processor <rfc2119>must</rfc2119>
create the corresponding ECMAScript object.  Otherwise, if the content is a valid
XML document, the Processor <rfc2119>must</rfc2119> create the corresponding DOM structure and assign it as the value of the variable.  Otherwise the
Processor <rfc2119>must</rfc2119> treat the content as a space-normalized string literal and assign
it as the value of the variable.  If no value is assigned, the SCXML Processor 
<rfc2119>must</rfc2119> assign the variable 
the default value ECMAScript undefined.   Note that the assignment takes place at the time indicated by
the 'binding' attribute on the &lt;scxml&gt; element. 
</p>



<example>
<head>Datamodel &lt;data> initialization</head>

<eg xml:space="preserve"><![CDATA[
<scxml version="1.0" xmlns="http://www.w3.org/2005/07/scxml" datamodel="ecmascript">
  <datamodel>
   <data id="employees" src="http://example.com/employees.json"/>
   <data id="year" expr="2008"/>
   <data id="CEO" expr="'Mr Big'"/>
   <data id="profitable" expr="true"/>
  </datamodel>
</scxml>
]]></eg>
</example>
</div3>
<div3 id="ecma-scoping">
<head>Scoping</head>
<p>The Processor <rfc2119>must</rfc2119> place all variables in a single global ECMAScript scope.
Specifically, the SCXML Processor <rfc2119>must</rfc2119> allow any data element to be accessed from any state.
Ordering dependencies between &lt;data&gt; elements are not permitted. 
	In the case of early binding, the SCXML Processor <rfc2119>must</rfc2119> evaluate all &lt;data&gt; 
	elements at initialization time but <rfc2119>may</rfc2119> do so in any order it chooses. 
	When late binding is selected, the SCXML Processor <rfc2119>must</rfc2119> create data model elements at initialization time 
	but <rfc2119>may</rfc2119> do so in any order it chooses. 
	Similarly, the processor <rfc2119>must</rfc2119> assign the specified initial values to data elements 
only when the state containing them is first entered, but <rfc2119>may</rfc2119> do so in any order it chooses. </p>  
</div3>

<div3 id="ecma_cond_expressions">
<head>Conditional Expressions</head>

<p>The Processor <rfc2119>must</rfc2119> convert ECMAScript expressions used in conditional expressions 
into their effective boolean value using the ToBoolean operator as
described in Section 9.2 of <bibref ref="ECMAScript262"/>.  </p>

<p>The following example illustrates this usage.</p>


<example>

<head>Use of a boolean expression to determine whether or not a
transition is taken.</head>


<eg xml:space="preserve"><![CDATA[
<state id="errorSwitch">
  <datamodel>
   <data id="time"/>
  </datamodel>
        
  <onentry>
    <assign location="time" expr="currentDateTime()"/>
  </onentry>
          
  <transition cond="yearFromDatetime(time) > 2009" target="newBehavior"/>
 
  <transition target="currentBehavior"/>
</state>
]]></eg>
</example>


 
  <p>The SCXML processor <rfc2119>must</rfc2119> define an
ECMAScript function named 'In()' that takes a stateID as its argument and
returns 'true' if and only if that state is in the current state configuration, as described in
 <specref ref="ConditionalExpressions"/>.  Here is an example of its use, taken from
  <specref ref="MicrowaveParallel"/> below:</p>

<example>
<eg xml:space="preserve"> 
  &lt;transition cond="In('closed')" target="cooking"/&gt;
</eg>
</example>


</div3>



<div3 id="ecma_location_expressions">
<head>Location Expressions</head>

<p>The SCXML Processor <rfc2119>must</rfc2119> accept any ECMAScript left-hand-side expression 
as a location expression. The following example illustrates this usage.  
(Note that the example assumes that the data loaded from
http://example.com/employees.json creates the necessary data structure, so
that employees.employee[12].salary exists when &lt;assign&gt; is evaluated. If it
didn't, the Processor would raise error.execution and the &lt;assign&gt; would have no effect.)</p>
  
<example>
<head>Use of the location attribute of the assign to update the salary of 
an employee. </head>
        
<eg xml:space="preserve"><![CDATA[
<state id="errorSwitch">
    <datamodel>
      <data id="employees" src="http://example.com/employees.json"/>
    </datamodel>
    
    <onentry>
        <assign location="employees.employee[12].salary" expr="42000"/>
    </onentry>
</state>]]></eg>
</example>



</div3>


<div3 id="ecma_value_expressions">
<head>Value Expressions</head>

<p>The SCXML Processor <rfc2119>must</rfc2119> accept any ECMAScript expression 
as a value expression. </p>


 <example>
 <head>Copying event data into the local data model for the state.</head>
 <eg xml:space="preserve"><![CDATA[
<state id="processEvent">
    <datamodel>
        <data id="myEvent"/>
    </datamodel>
    
    <onentry>
        <assign location="myEvent" expr="_event.data"/>
    </onentry>
</state>
]]></eg>
</example>
</div3>

<div3 id="ecma_inline_content">
<head>&lt;content&gt;</head>

<p> When &lt;content&gt; is a child of &lt;donedata&gt;, the Processor 
<rfc2119>must</rfc2119> interpret its value as defined in <specref ref="ecma_eventdata"/>.
When &lt;content&gt; is a child of &lt;send&gt;, the interpretation of its value depends on the
Event I/O Processor.  When &lt;content&gt; is a child of &lt;invoke&gt;, the interpretation of
its value is platform-specific. </p>
</div3>


<div3 id="ecma_assign">
	<head>&lt;assign&gt;</head>
	<p>
		When evaluating an &lt;assign&gt; element in the ECMAScript data model, the SCXML Processor
		<rfc2119>must</rfc2119> replace the existing value at 'location' with the value produced by
		evaluating 'expr'.  If it is unable to do so (for example, if the &lt;assign&gt; element attempts to assign to a read-only
		attribute), it <rfc2119>must</rfc2119> place the error error.execution on the
		internal event queue. 
		</p>
</div3>

<div3 id="ecma_system_variables">
<head>System Variables</head>


<p>The SCXML Processor <rfc2119>must</rfc2119> define
an ECMAScript read-only variable for each system variable defined
in <specref ref="SystemVariables"/>. The <code>_sessionid</code> and <code>_name</code>
system variables are defined as variables with ECMAScript String values.
The <code>_event</code> system variable is defined as an
object with properties for each of the fields defined in <specref ref="InternalStructureofEvents"/>: 
<code>name</code>,<code>type</code>, <code>sendid</code>, <code>origin</code>, <code>origintype</code>,
and <code>invokeid</code> are String values, while <code>data</code> can be of any type.  
In cases where this specification does not specify a value for one of these fields or
states that the field is empty or has no value,
the Processor <rfc2119>must</rfc2119> set the value to ECMAScript undefined.
As the value of the _ioprocessors system variable the Processor <rfc2119>must</rfc2119> create an object
with a named property for each Event I/O processor that it supports, where the name of the property 
is the same as that of the I/O processor and the value of the property is an object
that represents the I/O processor. For the SCXML and BasicHTTP Event I/O processors, 
the Processor <rfc2119>must</rfc2119> create a "location" property under that object, 
assigning the access URI as its String value. For example, in systems that support the 
BasicHTTP Event I/O Processor, the access URI of the BasicHTTP Event I/O processor 
can be accessed as _ioprocessors['http://www.w3.org/TR/scxml/#BasicHTTPEventProcessor'].location.

</p>

<div4 id="ecma_eventdata">
<head>_event.data</head>
<p> _event.data is populated with content provided by an external event
	or by &lt;param&gt; or &lt;content&gt;.  In some circumstances, the entity that generated the event 
	may have indicated how the data is to be interpreted. In such cases, the Processor <rfc2119>should</rfc2119> try to format 
	the data according to those indications. Otherwise, if the SCXML Processsor can interpret the content as key-value pairs,
	then for  each unique key, the  Processor <rfc2119>must</rfc2119> create a property
	of _event.data whose name is the name of the key-value pair and whose value is the value
	of the key-value pair. In
	the case of duplicate keys, the behavior is platform-specific.  (Note that
	content specified by &lt;param&gt; or delivered as POST parameters via the 
	BasicHTTP Event I/O Processor consists unambiguously of key-value pairs.)   Otherwise (i.e., if
	the content does not consist of key-value pairs), if the Processor supports JSON and
	it can interpret the content as JSON, it <rfc2119>must</rfc2119> create the
	corresponding ECMAScript object(s) as the value of _event.data.  Otherwise, if
	the Processor can interpret the content as a valid XML document, it <rfc2119>must</rfc2119> create the corresponding DOM structure and assign it as the value
	_event.data.  Otherwise, the Processor <rfc2119>must</rfc2119> treat the content
	as a space-normalized string literal and assign it as the value of _event.data.  </p>

</div4>



<p>Suppose as part of executing a state machine named "myName" with a
platform-assigned sessionid "12345", we are processing an event with
the name "foo.bar" and the following object payload:</p>
<example><eg xml:space="preserve">
<![CDATA[
    { "answer" : 42 }
]]>
</eg></example>

<p>Then the underlying ECMAScript data model would have the following form:</p>
<example>
<head>Illustration of system injected properties</head>
<eg xml:space="preserve">
<![CDATA[
{
  // The four properties below are automatically populated by the system

  "_name"      : "myName" ,
  "_sessionid" : "12345"  ,
  "_event"     : {
                    "name" : "foo.bar" ,
                    "data" : {
                               "answer"  :  42
                             }
                 } ,
  "_ioprocessors" : {
  "http://www.w3.org/TR/scxml/#BasicHTTPEventProcessor" : {
  "location" : "http://example.com/scxml-http/12345"
}
  "http://www.w3.org/TR/scxml/#SCXMLEventProcessor" :  {
  "location" : "http://example.com/scxml-http/23456"
}
} , 

  // Rest of the application / developer-authored data model goes here
}
]]>
</eg></example> 

<p>As an example, here is a sample transition that accesses the
<code>_event</code> variable in that data model.</p>
<example>
<head>Accessing system _event name in a condition </head>
<eg xml:space="preserve"><![CDATA[
<state id="checkEventName">
    <transition cond="_event.name=='foo.bar'" target="nextState">
     ...
    </transition>
</state>
]]></eg>
</example>


</div3>
<div3 id="ecma-serialization">
	<head>Serialization</head>
	<p>In certain circumstances, e.g. when including data in events sent via the BasicHTTP Event I/O Processor,
	the SCXML Processor is required to serialize  data from the ECMAScript data model for transmission to a remote
	entity.  In such cases, if the Processor supports JSON, and is able to serialize the data in sufficient detail to allow its reconstruction, 
	the Processor <rfc2119>must</rfc2119> serialize the data to JSON. Otherwise, the
	Processor <rfc2119>may</rfc2119> use platform-specific methods (including JSON despite the loss of information) 
	to serialize the data.  The
	Processor <rfc2119>should</rfc2119> provide a warning if the serialization entails
	loss of information or if it is unable to serialize at all.
		</p>
		</div3>

<div3 id="ecma_script_module">
<head>Scripting</head>


<p>
The SCXML Processor <rfc2119>must</rfc2119> accept any
ECMAScript program as defined in Section 14 of <bibref
ref="ECMAScript262"/> as the content of a &lt;script&gt; element.
</p>



</div3>



<div3 id="ecma_foreach">
<head>&lt;foreach&gt;</head>


<p>
In the ECMAScript data model, the SCXML Processor <rfc2119>must</rfc2119> support
iteration over objects that satisfy instanceof(Array) in ECMAScript. It 
<rfc2119>may</rfc2119> support iteration over other types of objects. 
The legal values for the 'item' attribute are legal ECMAScript variable names.
In cases where ECMAScript specification defines the iteration order for the object, the Processor <rfc2119>must</rfc2119> follow that ordering.  
(For arrays and strings, this goes from 0 to length-1.)  In cases where 
the ECMAScript specification does not define the iteration order, 
the Processor <rfc2119>may</rfc2119> follow any order that it chooses as long as
 1) it iterates over the 
object's own enumerable properties only 2) it visits each such property once and only once.
Note that since the Processor is required to behave as if it has made a shallow copy,
in the case of an array &lt;foreach&gt; assignment is equivalent to item = array_name[index] in ECMAScript.  Note also that  
	the assigned value could be undefined for a sparse array.
</p>

	<example>
		<head> Logging ISBN of all books in bookstore shopping cart </head>
<eg xml:space="preserve"><![CDATA[
<foreach array="cart.books" item="book">
<log expr="'Cart contains book with ISBN ' + book.isbn"/>
</foreach>
]]></eg>
</example>


</div3>


</div2>

</div1>
<div1 id="eventioprocessors">
	<head>Event I/O Processors</head>
	         <p>[This section is  normative.]</p>		
<div2 id="SCXMLEventProcessor">
	<head>SCXML Event I/O Processor</head>
	<p>
		The SCXML Event I/O Processor is intended to transport messages 
		between SCXML sessions.  This specification defines the mapping between the parameters in the sending
		session and the event that is raised in the receiving session, but the transport 
		mechanism is platform-specific. 
		</p>

		<p> The sending and receiving SCXML Processors <rfc2119>must</rfc2119> maintain the following mappings: </p>
			<ol>
				<li>The 'name' field of the event raised in the receiving session <rfc2119>must</rfc2119> match 
				the value of the 'event' attribute of
					the &lt;send&gt; element in the sending session. </li>
			<li>The 'origin' field of the event raised in the receiving session <rfc2119>must</rfc2119> match
					the value of the 'location' field inside the entry for the SCXML Event I/O Processor in the _ioprocessors system variable in the sending session. 
											</li>
							 
			<li>The 'sendid' field of the event raised in the receiving session <rfc2119>must</rfc2119>
			match the sendid in the sending session, if the author of the sending session specifies either
			the 'id' or 'idlocation' attribute.  If
			the author does not specify either the 'id' or 'idlocation' attribute,
			the 'sendid' field <rfc2119>must</rfc2119> be left empty.
								</li>
			<li>The 'origintype' field of the event raised in the receiving session <rfc2119>must</rfc2119>
					have the value "scxml".  	</li> 
		<li>The 'data' field of the event raised in the receiving session <rfc2119>must</rfc2119>
		contain a copy of the data specified in the 'namelist' attribute or 
		in &lt;param&gt; or &lt;content&gt; elements in the sending session. The nature of the copy operation
		depends on the data model in question.  However, the Processor <rfc2119>must</rfc2119> ensure
		that changes to the transmitted data in the receiving session do not affect the data in the
		sending session and vice-versa.  The format of the 
		'data' field will depend on the data model of the receiving session. See 
		<specref ref="profiles"/> for details.  If the data models
		in the sending and receiving sessions are different, the mapping between them is
		platform-specific.  
										</li>
				</ol>
	 <p>When using the SCXML Event I/O Processor, SCXML Processors <rfc2119>must</rfc2119> support the following special
	 targets for &lt;send&gt;:</p>
            <ul>
            	<li>#_internal. If the target is the special term '#_internal',
            the Processor <rfc2119>must</rfc2119> add the event to the internal event queue of the sending session.</li>
            <li>#_scxml_<em>sessionid</em>.  If the target is the special term '#_scxml_<em>sessionid</em>',
            where <em>sessionid</em> is the id of an SCXML session that is accessible to the Processor, the Processor <rfc2119>must</rfc2119>
            add the event to the external queue of that session.  The set of SCXML sessions that are 
            accessible to a given SCXML Processor is platform-dependent. </li>
            <li>#_parent.  If the target is the special term '#_parent', the Processor <rfc2119>must</rfc2119>
            add the event to the external event queue of
            	the SCXML session that invoked the sending session, if there is one.  See <specref ref="invoke"/>
            	for details.  </li>
            	<li>#_<em>invokeid</em>.  If the target is the special term 
            	'#_<em>invokeid</em>',
            where <em>invokeid</em> is the invokeid of an SCXML session that the sending session has  
            created by &lt;invoke&gt;, the Processor <rfc2119>must</rfc2119> add the event
             to the external queue of that session.  See <specref ref="invoke"/>
            	for details.</li>
            	</ul>
          <p>  	If neither the 'target' nor the 'targetexpr' attribute 
            is specified, the SCXML Processor <rfc2119>must</rfc2119> add the event to the 
            external event queue of the sending session.  
		</p>	
	<p>If the sending SCXML session specifies a session
		that does not exist or is inaccessible, the SCXML Processor <rfc2119>must</rfc2119> place the error
		error.communication on the internal event queue of the sending session. 
		 If the receiving Processor
		 cannot handle the data format contained in the message, the receiving Processor 
		 <rfc2119>must</rfc2119>
		 place the error error.communication in internal queue of the session for which the message was intended
		 and <rfc2119>must</rfc2119> ignore the message.  The Processor <rfc2119>should</rfc2119> also 
		 notify the sending processor of the error.   If no errors occur, the receiving Processor
		 <rfc2119>must</rfc2119> convert the message into an SCXML event,
		 using the mapping defined above, and insert the event into the appropriate queue, as defined
		 in <specref ref="SendTargets"/> </p>
	

<div3>
	<head>_ioprocessors Value</head>
	<p>SCXML Processors <rfc2119>must</rfc2119> maintain a 
	'http://www.w3.org/TR/scxml/#SCXMLEventProcessor' entry  in the _ioprocessors system variable.  The Processor <rfc2119>must</rfc2119> 
	maintain a 'location' field inside this  entry whose value  
  holds an address that external entities can use to communicate
           with this SCXML session using the SCXML Event I/O Processor.
		</p>
		</div3>
<div3>
	<head>Examples</head>
		<p>Here are some examples of SCXML messages sent between SCXML sessions.
			  Each example shows the original &lt;send&gt; element and a transition 
			  handling the resulting
			event in the receiving SCXML session.   </p>
			<p><em>EXAMPLE 1:</em>  First, here is a message with an XML payload generated
			by &lt;send&gt; with a 'namelist':
			</p>
			<eg xml:space="preserve"><xi:include href="SCXMLExamples/scxml-event-example-xpath-1a.xml" parse="text"/></eg>

<p>Here is sample SCXML code to process that event in the receiving SCXML session.
	In this example &lt;my:email&gt; is platform-specific
			executable content that sends an email:
	</p>
	<eg xml:space="preserve"><xi:include href="SCXMLExamples/scxml-event-example-xpath-1c.xml" parse="text"/></eg>


<p><em>EXAMPLE 2:</em> The next example shows &lt;send&gt; using inline XML content: </p>					
			<eg xml:space="preserve"><xi:include href="SCXMLExamples/scxml-event-example-xpath-2a.xml" parse="text"/></eg>

<p>Here is sample SCXML code to process the resulting event in the receiving SCXML session. 
	It uses the special executable content
	&lt;csta:makecall&gt; to generate a telephone call:
	<eg xml:space="preserve"><xi:include href="SCXMLExamples/scxml-event-example-xpath-2c.xml" parse="text"/></eg>
	</p>
	


<p><em>EXAMPLE 3:</em> Finally, here is an example generated by &lt;send&gt; using both 'event' and 'namelist' attributes
	and using JSON content:</p>									
<eg xml:space="preserve"><xi:include href="SCXMLExamples/scxml-event-example-json-1a.xml" parse="text"/></eg>
 
	<p>Here is sample SCXML code to process the resulting event in the receiving SCXML session. 
		In this example, &lt;my:email&gt; is special executable content as in the
	first example.</p>
<eg xml:space="preserve"><xi:include href="SCXMLExamples/scxml-event-example-json-1c.xml" parse="text"/></eg>
</div3>
	
			
	</div2>

<div2 id="BasicHTTPEventProcessor">
	<head>Basic HTTP Event I/O Processor</head>
	<p>The Basic HTTP Event I/O Processor is intended as a minimal interoperable mechanism for sending and 
receiving events to and from external components and SCXML 1.0 implementations.  Support for the Basic HTTP Event I/O Processor
 is optional.  
</p>

	<div3>
		<head>Receiving Events</head>
		<p>
	An SCXML Processor that supports the Basic HTTP Event I/O Processor <rfc2119>must</rfc2119>
	accept messages at the access URI as HTTP POST requests (see <bibref ref="HTTP"/>). 
The SCXML Processor <rfc2119>must</rfc2119> validate the message it receives and then
<rfc2119>must</rfc2119> build the appropriate SCXML event
and <rfc2119>must</rfc2119> add it to the external event queue.</p>
<p>
If a single instance of the parameter '_scxmleventname' 
	 is present, the SCXML Processor <rfc2119>must</rfc2119> use its value as the name of the
	 SCXML event that it raises. If multiple instances of the parameter are present, the behavior
	 is platform-specific. If the parameter '_scxmleventname' 
	 is not present, the SCXML Processor <rfc2119>must</rfc2119> use the name of the HTTP method that
	 was used to deliver the message as the
	 name of the event that it raises.  The processor  <rfc2119>must</rfc2119> use any message content
	 other than '_scxmleventname' to populate _event.data. See <specref ref="profiles"/> for details.</p>
	
<p>After it adds the received message to the appropriate event queue, the 
	SCXML Processor <rfc2119>must</rfc2119> then indicate
 the result to the external component 
via a success response code 2XX.  Note that this response is sent before the event is 
removed from the queue and processed. In the cases where the message cannot be formed into an SCXML event, the Processor 
<rfc2119>must</rfc2119> return an HTTP error code as defined in <bibref ref="HTTP"/>.  
 
</p>



	</div3>
<div3>
	<head>Sending Events</head>
<p>An SCXML implementation can send events with the Basic HTTP Event I/O Processor
	 using the &lt;send&gt; element (see <specref ref="send"/>) with the type attribute set to "http://www.w3.org/TR/scxml/#BasicHTTPEventProcessor"
	 and the target attribute set to the access URI of the target.  If neither the 'target' nor the 'targetexpr' attribute 
            is specified, the SCXML Processor <rfc2119>must</rfc2119> add the event error.communication to the 
            internal event queue of the sending session.  
		</p>
<p>
The SCXML Processor <rfc2119>must</rfc2119> attempt to deliver the message using HTTP method "POST" and 
with parameter values encoded by default in an 
application/x-www-form-urlencoded body (POST method).  An SCXML Processor <rfc2119>may</rfc2119>
support other encodings, and allow them to be specified in a platform-specific way.
</p>

<p>
If the 'event' parameter of &lt;send&gt; is defined, the SCXML Processor <rfc2119>must</rfc2119>
use its value as the value of the HTTP POST parameter _scxmleventname.  
If the namelist attribute is defined, the SCXML Processor <rfc2119>must</rfc2119> map 
its variable names and values  to HTTP POST parameters. 
If one or more &lt;param&gt; children are present,  the SCXML Processor <rfc2119>must</rfc2119> map
their names (i.e. name attributes) and values 
to HTTP POST parameters. If a &lt;content&gt; child is present, the SCXML Processor <rfc2119>must</rfc2119> use 
its value as the body of the message.  
</p>

	</div3>
	<div3>
	<head>_ioprocessors Value</head>
	<p> SCXML Processors that support the BasicHTTP Event I/O Processor  <rfc2119>must</rfc2119> maintain a 
	'http://www.w3.org/TR/scxml/#BasicHTTPEventProcessor' entry  in the _ioprocessors system variable.  The Processor <rfc2119>must</rfc2119> 
	maintain a 'location' field inside this  entry whose value  
  holds an address that external entities can use to communicate
           with this SCXML session using the Basic HTTP Event I/O Processor.
		</p>
		</div3>
</div2>

	    </div1>
	    <div1 id="AlgorithmforSCXMLInterpretation">
    <head>Algorithm for SCXML Interpretation</head>
    <p>[This section is informative.]</p>
    <p> This section contains an illustrative algorithm for the interpretation of 
    an SCXML document.  It is intended as a guide for implementers only.
Implementations are free to implement
    SCXML interpreters in any way they choose. </p>

<h2 id="InformalSemantics">Informal Semantics</h2>

<p>The following definitions and highlevel principles and constraint are intended to provide a background to the algorithm, 
	and to serve as a guide for the proper understanding of it.</p>
<h3 id="PrelimaryDefinitions">Preliminary definitions</h3>

<glist>
  <label>state</label>
  <def>An element of type &lt;state&gt;, &lt;parallel&gt;, or &lt;final&gt;.</def>
  <label>pseudo state</label>
  <def>An element of type &lt;initial&gt; or &lt;history&gt;.</def>
  <label>transition target</label>
  <def>A state, or an element of type &lt;history&gt;.</def>
  <label>atomic state</label>
  <def>A state of type &lt;state&gt; with no child states, or a state of type &lt;final&gt;.</def>
  <label>compound state</label>
  <def>A state of type &lt;state&gt; with at least one child state.</def>
  <label>configuration</label>
  <def>The maximal consistent set of states (including parallel and final states) that the machine is currently in. We note that if a state s is in the configuration c, it is always the case that the parent of s (if any) is also in c. Note, however, that &lt;scxml&gt; is not a(n explicit) member of the configuration.</def>
  <label>source state</label>
  <def>The source state of a transition is the state which contains the transition.</def>
  <label>target state</label>
  <def>A target state of a transition is a state that the transition is entering. Note that a transition can have zero or more target states.</def>
  <label>targetless transition</label>
  <def>A transition having zero target states.</def>
  <label>eventless transition</label>
  <def>A transition lacking the 'event' attribute.</def>
  <label>external event</label>
  <def>An SCXML event appearing in the external event queue. Such events are either sent by 
  	external sources or generated with the &lt;send&gt; element.</def>
  <label>internal event</label>
  <def>An event appearing in the internal event queue. Such events are either raised automatically 
  	by the platform or generated with the &lt;raise&gt; or &lt;send&gt; elements.</def>
  <label>microstep</label>
  <def>A microstep involves the processing of a single transition (or, in the case of parallel states,
  	a single set of transitions.) A microstep may change the current configuration, update the data model 
   and/or generate new (internal and/or external) events. This, by causality, may in turn enable additional 
  transitions which will be handled in the next microstep in the sequence, and so on.</def>
  <label>macrostep</label>
  <def>A macrostep consists of a sequence (a chain) of microsteps, at the end of which the state machine
  	is in a stable state and ready to process an external event. 
  	Each external event causes an SCXML state machine to take exactly one macrostep. 
  	However, if the external event does not enable any transitions, no microstep will be taken, 
  	and the corresponding macrostep will be empty.</def>

</glist>
<h3 id="PrinciplesandConstraints">Principles and Constraints</h3>

<p>We state here some principles and constraints, on the level of semantics, that SCXML adheres to:</p>
<glist>
<label>Encapsulation</label>
<def>An SCXML processor is a <emph>pure event processor</emph>. The only way to get data into an SCXML state machine is to send external events to it. The only way to get data out is to receive events from it.</def>
<label>Causality</label>
<def>There shall be a <emph>causal justification</emph> of why events are (or are not) returned back to the environment, which can be traced back to the events provided by the system environment. </def>
<label>Determinism</label>
<def>An SCXML state machine which does not invoke any external event processor must always react with the same behavior (i.e. the same sequence of output events) to a given sequence of input events (unless, of course, the state machine is explicitly programmed to exhibit an non-deterministic behavior). In particular, the availability of the &lt;parallel&gt; element must not introduce any non-determinism of the kind often associated with concurrency. Note that observable determinism does not necessarily hold for state machines that invoke other event processors.</def>
<label>Completeness</label>
<def>An SCXML interpreter must always treat an SCXML document as <emph>completely</emph> specifying the behavior of a state machine. In particular, SCXML is designed to use priorities (based on document order) to resolve situations which other state machine frameworks would allow to remain under-specified (and thus non-deterministic, although in a different sense from the above).</def>
<label>Run to completion</label>
<def>SCXML adheres to a run to completion semantics in the sense that an external event can only be processed when the processing of the previous external event has completed, i.e. when all microsteps (involving all triggered transitions) have been completely taken.</def>
<label>Termination</label>
<def>A microstep always terminates. A macrostep may not. A macrostep that does not terminate may be said to consist of an infinitely long sequence of microsteps. This is currently allowed.</def>
</glist>
<h2 id="Algorithm">Algorithm</h2>
<p>Note that the algorithm assumes a Lisp-like semantics in which the empty Set null is equivalent
	to boolean 'false' and all other entities are equivalent to 'true'.
</p>
<h3 id="Datatypes">Datatypes</h3>
<p>These are the abstract datatypes that are used in the algorithm.</p>
<pre>
datatype List
   <code>function</code> head()      // Returns the head of the list
   <code>function</code> tail()      // Returns the tail of the list (i.e., the rest of the list once the head is removed)
   <code>function</code> append(l)   // Returns the list appended with l
   <code>function</code> filter(f)   // Returns the list of elements that satisfy the predicate f
   <code>function</code> some(f)     // Returns true if some element in the list satisfies the predicate f.  Returns false for an empty list.
   <code>function</code> every(f)    // Returns true if every element in the list satisfies the predicate f.  Returns true for an empty list.
The notation [...] is used as a list constructor, so that '[t]' denotes a list whose only member is the object t.
 
datatype OrderedSet
   <code>procedure</code> add(e)              // Adds e to the set if it is not already a member
   <code>procedure</code> delete(e)           // Deletes e from the set
   <code>procedure</code> union(s)            // Adds all members of s that are not already members of the set (s must also be an OrderedSet)
   <code>function</code> isMember(e)          // Is e a member of set?
   <code>function</code> some(f)              // Returns true if some element in the set satisfies the predicate f.  Returns false for an empty set.
   <code>function</code> every(f)             // Returns true if every element in the set satisfies the predicate f. Returns true for an empty set.
   <code>function</code> hasIntersection(s)   // Returns true if this set and  set s have at least one member in common
   <code>function</code>  isEmpty()           // Is the set empty?
   <code>procedure</code> clear()             // Remove all elements from the set (make it empty) 
   <code>function</code>  toList()            // Converts the set to a list that reflects the order in which elements were originally added
                                 // In the case of sets created by intersection, the order of the first set (the one on which the method was called) is used 
                                 // In the case of sets created by union, the members of the first set (the one on which union was called) retain their original ordering
                                 // while any members belonging to the second set only are placed after, retaining their ordering in their original set. 
 

datatype Queue
   <code>procedure</code> enqueue(e) // Puts e last in the queue
   <code>function</code> dequeue()   // Removes and returns first element in queue
   <code>function</code> isEmpty()   // Is the queue empty?

datatype BlockingQueue
   <code>procedure</code> enqueue(e) // Puts e last in the queue
   <code>function</code> dequeue()   // Removes and returns first element in queue, blocks if queue is empty

datatype HashTable // table[foo] returns the value associated with foo.  table[foo] = bar sets the value associated with foo to be bar.
</pre>


 <h3 id="GlobalVariables">Global variables</h3>
 <p>The following variables are global from the point of view of the algorithm. Their values will be set in the procedure interpret().</p>
<pre>global configuration
global statesToInvoke
global datamodel
global internalQueue
global externalQueue
global historyValue
global running
global binding

 </pre>
 <h3 id="Predicates">Predicates</h3>
 <p>The following binary predicates are used for determining the order in which states are entered and exited. </p>
 <pre>
<code><a name="entryOrder">entryOrder</a></code> // Ancestors precede descendants, with document order being used to break ties 
	(Note:since ancestors precede descendants, this is equivalent to document order.)
<code><a name="exitOrder">exitOrder</a></code>  // Descendants precede ancestors, with reverse document order being used to break ties 
	(Note: since descendants follow ancestors, this is equivalent to reverse document order.)
</pre>
<p>The following binary predicate is used to determine the order in which
	we examine transitions within a state.</p>
	<pre>
<code><a name="documentOrder">documentOrder</a></code>// The order in which the elements occurred in the original document.
</pre>

 	
 <h3 id="ProceduresandFunctions">Procedures and Functions</h3>
 <p>This section defines the procedures and functions that make up the core of the SCXML interpreter.
 	N.B. in the code below, the keyword 'continue' has its traditional meaning in languages like C:
 	break off the current iteration of the loop and proceed to the next iteration.</p>
 <h4 id="interpret"><code>procedure</code> interpret(scxml,id)</h4>
 <p>The purpose of this procedure is to initialize the interpreter and to start processing. 
</p>
 <p>In order to interpret an SCXML document, first 
(optionally) perform <bibref ref="xinclude"/> processing and (optionally) validate the document, throwing an exception if 
 validation fails. Then convert initial 
 attributes to &lt;initial&gt; container children with transitions to the state specified by
 the attribute. (This step is done purely to simplify the statement of the algorithm and has no effect
 on the system's behavior. Such transitions will not contain any executable content).  
 Initialize the global data structures, including the data model. If binding is set to 'early', initialize
 the data model.  Then  execute the global &lt;script&gt; element, if any.  
Finally call enterStates on the initial configuration, set the global running variable to true and start the interpreter's event loop.
</p>
<pre>
procedure interpret(doc):
    if not valid(doc): failWithError()
    expandScxmlSource(doc)
    configuration = new OrderedSet()
    statesToInvoke = new OrderedSet()
    internalQueue = new Queue()
    externalQueue = new BlockingQueue()
    historyValue = new HashTable()
    datamodel = new Datamodel(doc)
    if doc.binding == "early":
        initializeDatamodel(datamodel, doc)
    running = true
    executeGlobalScriptElement(doc)
    enterStates([doc.initial.transition])
    mainEventLoop()
</pre>


<h4 id="mainEventLoop"><code>procedure</code> mainEventLoop()</h4>
<p>This loop runs until we enter a top-level final state or an external entity cancels processing.  
	In either case 'running' will be set to false (see EnterStates, below, for termination by entering
	a top-level final state.)</p>
		<p>At the top of the loop, we have either just entered the state machine, or  we have just
			processed an external event.  Each iteration through the loop consists of four main steps: 
			1)Complete the macrostep by repeatedly taking any internally enabled transitions, namely those that don't require an event or that are triggered
		by an internal event. After each such transition/microstep, check to see if we have reached a final state. 
		2) When there are no more internally enabled transitions available, the macrostep is done.  Execute any &lt;invoke&gt; tags for states that we entered on the 
		last iteration through the loop 3) If any internal events have been generated by the invokes,
		repeat step 1 to handle any errors raised by the 
		&lt;invoke&gt; elements. 
		4) When the internal event queue is empty, wait
		for an external event and then execute any transitions that it triggers.  However special 
		preliminary processing is applied to the event if the state has executed any &lt;invoke&gt; 
		elements. First, if this event was generated by an invoked process, apply &lt;finalize&gt; 
		processing to it. Secondly, if any &lt;invoke&gt; elements have autoforwarding set, forward
		the event to them.  These steps apply before the transitions are taken.   </p>

		<p> This event loop thus enforces run-to-completion semantics, in which
		the system process an external event and then takes all the 'follow-up' transitions that
		the processing has enabled before looking for another external event.  For example, suppose
		that the <em>external</em> event queue contains events ext1 and ext2 and the machine is in state s1.  If processing
		ext1 takes the machine to s2 and generates <em>internal</em> event int1, and s2 contains a transition t
		triggered by int1, the system is guaranteed to take t, no matter what transitions s2 or other
		states have that would be triggered by ext2.  Note that this is true even though ext2 was already in the
		external event queue when int1 was generated. In effect, the algorithm treats the processing of int1
		as finishing up the processing of ext1. </p>

<pre>
procedure mainEventLoop():
    while running:
        enabledTransitions = null
        macrostepDone = false
        # Here we handle eventless transitions and transitions 
        # triggered by internal events until macrostep is complete
        while running and not macrostepDone:
            enabledTransitions = selectEventlessTransitions()
            if enabledTransitions.isEmpty():
                if internalQueue.isEmpty(): 
                    macrostepDone = true
                else:
                    internalEvent = internalQueue.dequeue()
                    datamodel["_event"] = internalEvent
                    enabledTransitions = selectTransitions(internalEvent)
            if not enabledTransitions.isEmpty():
                microstep(enabledTransitions.toList())
        # either we're in a final state, and we break out of the loop 
        if not running:
            break
        # or we've completed a macrostep, so we start a new macrostep by waiting for an external event
        # Here we invoke whatever needs to be invoked. The implementation of 'invoke' is platform-specific
        for state in statesToInvoke.sort(entryOrder):
            for inv in state.invoke.sort(documentOrder):
                invoke(inv)
        statesToInvoke.clear()
        # Invoking may have raised internal error events and we iterate to handle them        
        if not internalQueue.isEmpty():
            continue
        # A blocking wait for an external event.  Alternatively, if we have been invoked
        # our parent session also might cancel us.  The mechanism for this is platform specific,
        # but here we assume it’s a special event we receive
        externalEvent = externalQueue.dequeue()
        if isCancelEvent(externalEvent):
            running = false
            continue
        datamodel["_event"] = externalEvent
        for state in configuration:
            for inv in state.invoke:
                if inv.invokeid == externalEvent.invokeid:
                    applyFinalize(inv, externalEvent)
                if inv.autoforward:
                    send(inv.id, externalEvent) 
        enabledTransitions = selectTransitions(externalEvent)
        if not enabledTransitions.isEmpty():
            microstep(enabledTransitions.toList()) 
    # End of outer while running loop.  If we get here, we have reached a top-level final state or have been cancelled          
    exitInterpreter()            
</pre>
	   


 <h4 id="exitInterpreter"><code>procedure</code> exitInterpreter()</h4>
 <p>The purpose of this procedure is to exit the current SCXML process by exiting
 all active states.  If the machine is in a top-level final state, a Done event is generated.
 (Note that in this case, the final state will be the only active state.)  The implementation
 of returnDoneEvent is platform-dependent, but if this session is the result of an &lt;invoke&gt;
 in another SCXML session, returnDoneEvent will cause the event done.invoke.&lt;id&gt; to be
 placed in the external event queue of that session, where &lt;id&gt;
 is the id generated in that
 session when the &lt;invoke&gt; was executed. 	
 </p>
<pre>
procedure exitInterpreter():
    statesToExit = configuration.toList().sort(exitOrder)
    for s in statesToExit:
        for content in s.onexit.sort(documentOrder):
            executeContent(content)
        for inv in s.invoke:
            cancelInvoke(inv)
        configuration.delete(s)
        if isFinalState(s) and isScxmlElement(s.parent):   
            returnDoneEvent(s.donedata)
</pre>

<h4 id="selectEventlessTransitions"><code>function</code> selectEventlessTransitions()</h4>
<p>This function selects all transitions that are enabled in the current configuration that do not 
	require an event trigger.  First find a transition with no 'event' attribute   
   whose condition evaluates to <code>true</code>. 
 If multiple matching transitions are present, take the first 
 in document order. If none are present, search in the state's 
 ancestors in ancestry order until one is found. As soon as such a transition 
 is found, add it to enabledTransitions, and proceed to the next atomic state 
 in the configuration. If no such transition is found in the state 
 or its ancestors, proceed to the next state in the configuration. 
 When all atomic states have been visited and transitions selected, 
 filter the set of enabled transitions, removing any that are preempted by other
 transitions, then return the resulting set.</p>
<pre>
function selectEventlessTransitions():
    enabledTransitions = new OrderedSet()
    atomicStates = configuration.toList().filter(isAtomicState).sort(documentOrder)
    for state in atomicStates:
        loop: for s in [state].append(getProperAncestors(state, null)):
            for t in s.transition.sort(documentOrder):
                if not t.event and conditionMatch(t): 
                    enabledTransitions.add(t)
                    break loop
    enabledTransitions = removeConflictingTransitions(enabledTransitions)
    return enabledTransitions
</pre>

<h4 id="selectTransitions"><code>function</code> selectTransitions(event)</h4>
<p>The purpose of the selectTransitions()procedure is to collect 
the transitions that are enabled by this event in the current configuration. </p>
<p>Create an empty set of <code>enabledTransitions</code>. For each atomic state , 
find a transition whose 'event' attribute matches 
 <code>event</code> and whose condition evaluates to <code>true</code>. 
 If multiple matching transitions are present, take the first 
 in document order. If none are present, search in the state's 
 ancestors in ancestry order until one is found. As soon as such a transition 
 is found, add it to enabledTransitions, and proceed to the next atomic state 
 in the configuration. If no such transition is found in the state 
 or its ancestors, proceed to the next state in the configuration. 
 When all atomic states have been visited and transitions selected, 
 filter out any preempted transitions and return the resulting set.</p>
<pre>
function selectTransitions(event):
    enabledTransitions = new OrderedSet()
    atomicStates = configuration.toList().filter(isAtomicState).sort(documentOrder)
    for state in atomicStates:
        loop: for s in [state].append(getProperAncestors(state, null)):
            for t in s.transition.sort(documentOrder):
                if t.event and nameMatch(t.event, event.name) and conditionMatch(t):
                    enabledTransitions.add(t)
                    break loop
    enabledTransitions = removeConflictingTransitions(enabledTransitions)
    return enabledTransitions
</pre>


<h4 id="removeConflictingTransitions"><code>function</code> removeConflictingTransitions(enabledTransitions)</h4>
<p>enabledTransitions will contain	multiple transitions only if a parallel state is active.  In that case, we may have
	one transition selected for each of its children.  These transitions may conflict
	with each other in the sense that they have incompatible target states. Loosely speaking,
	transitions are compatible when each one is contained within a single &lt;state&gt; child
	of the &lt;parallel&gt; element.  Transitions that aren't contained within a single child force
	the state machine to leave the &lt;parallel&gt; ancestor (even
	if they reenter it later).  Such transitions conflict with each other, and with transitions
	that remain within a single &lt;state&gt; child, in that they may have targets
	that cannot be simultaneously active.  The test that transitions have non-intersecting
	exit sets captures this requirement.  (If the intersection is null, the source and targets
	of the two transitions are contained
	in separate &lt;state&gt; descendants of &lt;parallel&gt;.  If intersection is non-null, then
	at least one of the transitions is exiting the &lt;parallel&gt;).  When
	such a conflict occurs, then if the source state of one of the transitions
	is a descendant of the source state of the other, we select the transition in the descendant.
	Otherwise we prefer the transition that was selected by the earlier state in document order and
	discard the other transition.   Note that targetless transitions have empty exit sets and thus 
	do not conflict with any other transitions.  </p>
	<p>We start with a list of enabledTransitions and produce a conflict-free list
		of filteredTransitions.  For each t1 in enabledTransitions, we test it against
		all t2 that are already selected in filteredTransitions.  If there is a conflict,
		then if t1's source state is a descendant of t2's source state, we prefer t1
		and say that it preempts t2
		(so we we make a note to remove t2 from filteredTransitions). Otherwise, we prefer
		t2 since it was selected in an earlier state in document order, so we say
		that it preempts t1. (There's no
		need to do anything in this case since t2 is already in filteredTransitions.
		Furthermore, once one transition preempts t1, there is no need to test t1 against
		any other transitions.)
		Finally, if t1 isn't preempted by any transition in filteredTransitions,
		remove any transitions that it preempts and add it to that list.  </p>
<pre>
function removeConflictingTransitions(enabledTransitions):
    filteredTransitions = new OrderedSet()
    //toList sorts the transitions in the order of the states that selected them
    for t1 in enabledTransitions.toList():
        t1Preempted = false
        transitionsToRemove = new OrderedSet()
        for t2 in filteredTransitions.toList():
            if computeExitSet([t1]).hasIntersection(computeExitSet([t2])):
                if isDescendant(t1.source, t2.source):
                    transitionsToRemove.add(t2)
                else: 
                    t1Preempted = true
                    break
        if not t1Preempted:
            for t3 in transitionsToRemove.toList():
                filteredTransitions.delete(t3)
            filteredTransitions.add(t1)
           
    return filteredTransitions</pre>


<h4 id="microstepProcedure"><code>procedure</code> microstep(enabledTransitions)</h4>
<p>The purpose of the microstep <code>procedure</code> is to process a single set of 
transitions.  These may have been enabled by an external event, an internal event, or 
by the presence or absence of certain values in the data model at the current point in time. 
The processing of the enabled transitions must be done in parallel ('lock step') in the sense 
that their source states must first be exited, then their actions must be executed, and finally 
their target states entered.</p>
<p>If a single atomic state is active, then enabledTransitions will contain only a single transition. 
If multiple states are active (i.e., we are in a parallel region), then there may be multiple
transitions, one per active atomic state (though some states may not select a transition.)  In this case, the transitions are taken
in the document order of the atomic states that selected them.  </p>
<pre>
procedure microstep(enabledTransitions):
    exitStates(enabledTransitions)
    executeTransitionContent(enabledTransitions)
    enterStates(enabledTransitions)
</pre>

<h4 id="exitStates"><code>procedure</code> exitStates(enabledTransitions)</h4>
<p>Compute the set of states to exit.  Then remove all the states on statesToExit from
the set of states that will have invoke processing done at the start of the next macrostep.  
(Suppose macrostep M1 consists of microsteps m11 and m12.  We may enter state s in m11
and exit it in m12.  We will add s to statesToInvoke in m11, and must remove it in m12.
In the subsequent macrostep M2, we will apply invoke processing to all states that were
entered, and not exited, in M1.)  
Then convert statesToExit to a list and sort it in 
exitOrder.</p>
<p>For each state s in the list, if s has a deep history state h, set the history value of h 
	to be the list of all atomic descendants of s that are members in the current configuration, 
	else set its value to be the list of all immediate children of s that are members of the 
	current configuration. Again for each state s in the list, first execute any onexit 
	handlers, then cancel any ongoing invocations, and finally remove s from the current
	configuration.</p>

<pre>
procedure exitStates(enabledTransitions):
    statesToExit = computeExitSet(enabledTransitions)           
    for s in statesToExit:
        statesToInvoke.delete(s)
    statesToExit = statesToExit.toList().sort(exitOrder)
    for s in statesToExit:
        for h in s.history:
            if h.type == "deep":
                f = lambda s0: isAtomicState(s0) and isDescendant(s0,s) 
            else:
                f = lambda s0: s0.parent == s
            historyValue[h.id] = configuration.toList().filter(f)
    for s in statesToExit:
        for content in s.onexit.sort(documentOrder):
            executeContent(content)
        for inv in s.invoke:
            cancelInvoke(inv)
        configuration.delete(s)
</pre>

<h4 id="computeExitSet"><code>procedure</code> computeExitSet(enabledTransitions)</h4>
<p>For each transition t in 
enabledTransitions, if t is targetless then do nothing, else compute the transition's domain.
(This will be the source state in the case of internal transitions) or the least common compound ancestor 
state of the source state and target states of t (in the case of external transitions. Add to the statesToExit set all states in the 
configuration that are descendants of the domain.</p>
<pre>
function computeExitSet(transitions)
    statesToExit = new OrderedSet
    for t in transitions:
        if t.target:
            domain = getTransitionDomain(t)
            for s in configuration:
                if isDescendant(s,domain):
                    statesToExit.add(s)
    return statesToExit   
	</pre>
<h4 id="executeTransitionContent"><code>procedure</code> executeTransitionContent(enabledTransitions)</h4>
<p>For each transition in the list of <code>enabledTransitions</code>, execute its executable content. </p>
<pre>
procedure executeTransitionContent(enabledTransitions):
    for t in enabledTransitions:
        executeContent(t)
</pre>

<h4 id="enterStates"><code>procedure</code> enterStates(enabledTransitions)</h4>

<p>  
First, compute the list of all the states that will be entered as a result of taking the
transitions in enabledTransitions.  Add them to statesToInvoke so that invoke processing can
be done at the start of the next macrostep. 
Convert statesToEnter to a list and sort it in entryOrder.
For each state s in the list, first add s to the current configuration. Then if we are using
late binding, and this is the first time we have entered s, initialize its data model. 
Then execute any onentry handlers.  If s's initial state is being entered by default, execute
any executable content in the initial transition.  If a history state in s was the target
of a transition, and s has not been entered before, execute the content inside the history
state's default transition. Finally, if s is a final state, 
generate relevant Done events. If we have reached a top-level final state, set running to false as a
signal to stop processing. </p>
<pre>
procedure enterStates(enabledTransitions):
    statesToEnter = new OrderedSet()
    statesForDefaultEntry = new OrderedSet()
    // initialize the temporary table for default content in history states
    defaultHistoryContent = new HashTable() 
    computeEntrySet(enabledTransitions, statesToEnter, statesForDefaultEntry, defaultHistoryContent) 
    for s in statesToEnter.toList().sort(entryOrder):
        configuration.add(s)
        statesToInvoke.add(s)
        if binding == "late" and s.isFirstEntry:
            initializeDataModel(datamodel.s,doc.s)
            s.isFirstEntry = false
        for content in s.onentry.sort(documentOrder):
            executeContent(content)
        if statesForDefaultEntry.isMember(s):
            executeContent(s.initial.transition)
        if defaultHistoryContent[s.id]:
            executeContent(defaultHistoryContent[s.id]) 
        if isFinalState(s):
            if isSCXMLElement(s.parent):
                running = false
            else:
                parent = s.parent
                grandparent = parent.parent
                internalQueue.enqueue(new Event("done.state." + parent.id, s.donedata))
                if isParallelState(grandparent):
                    if getChildStates(grandparent).every(isInFinalState):
                        internalQueue.enqueue(new Event("done.state." + grandparent.id))
 
</pre>

<h4 id="computeEntrySet"><code>procedure</code> computeEntrySet(transitions, statesToEnter, statesForDefaultEntry, defaultHistoryContent)</h4>
<p>Compute the complete set of states that will be entered as a result of taking 'transitions'.  This
	value will be returned in 'statesToEnter' (which is modified by this procedure).  Also place
	in 'statesForDefaultEntry' the set of all states whose default initial states were entered.  First gather
	up all the target states in 'transitions'.  Then add them and, for all that are not atomic
	states, add all of their (default) descendants until we reach one or more atomic states.  Then
	add any ancestors that will be entered within the domain of the transition.  (Ancestors outside
of the domain of the transition will not have been exited.)</p>
	<pre>
procedure computeEntrySet(transitions, statesToEnter, statesForDefaultEntry, defaultHistoryContent)
    for t in transitions:
        for s in t.target:
            addDescendantStatesToEnter(s,statesToEnter,statesForDefaultEntry, defaultHistoryContent) 
        ancestor = getTransitionDomain(t) 
        for s in getEffectiveTargetStates(t)):            
            addAncestorStatesToEnter(s, ancestor, statesToEnter, statesForDefaultEntry, defaultHistoryContent)
</pre>                       

<h4 id="addDescendantStatesToEnter"><code>procedure</code> addDescendantStatesToEnter(state,statesToEnter,statesForDefaultEntry, defaultHistoryContent)</h4>
<p>The purpose of this procedure is to add to statesToEnter 'state' 
	and any of its descendants that the state machine will end up entering 
	when it enters 'state'. (N.B. If 'state' is a history pseudo-state, 
	we dereference it and add the history value instead.) Note that this procedure 
	permanently modifies both statesToEnter and statesForDefaultEntry.</p>
<p>
First, If state is a history state then add either the history 
values associated with state or state's default target to statesToEnter. 
Then (since the history value may not be an immediate descendant of 'state's parent)
add any ancestors between the history value and state's parent.
Else (if state is not a history state), add state to statesToEnter.  Then if state is a compound state, add state to statesForDefaultEntry 
and recursively call addStatesToEnter on its default initial state(s). 
Then, since the default initial states may not be children of 'state',
add any ancestors between the default initial states and 'state'.
Otherwise, if state is a parallel state, recursively call addStatesToEnter
on any of its child states that don't already have a descendant on statesToEnter.
</p>
<pre>
procedure addDescendantStatesToEnter(state,statesToEnter,statesForDefaultEntry, defaultHistoryContent):
    if isHistoryState(state):
        if historyValue[state.id]:
            for s in historyValue[state.id]:
                addDescendantStatesToEnter(s,statesToEnter,statesForDefaultEntry, defaultHistoryContent)
            for s in historyValue[state.id]:
                addAncestorStatesToEnter(s, state.parent, statesToEnter, statesForDefaultEntry, defaultHistoryContent)
        else:
            defaultHistoryContent[state.parent.id] = state.transition.content
            for s in state.transition.target:
                addDescendantStatesToEnter(s,statesToEnter,statesForDefaultEntry, defaultHistoryContent)
            for s in state.transition.target:     
                addAncestorStatesToEnter(s, state.parent, statesToEnter, statesForDefaultEntry, defaultHistoryContent)
    else:
        statesToEnter.add(state)
        if isCompoundState(state):
            statesForDefaultEntry.add(state)
            for s in state.initial.transition.target:
                addDescendantStatesToEnter(s,statesToEnter,statesForDefaultEntry, defaultHistoryContent)
            for s in state.initial.transition.target:    
                addAncestorStatesToEnter(s, state, statesToEnter, statesForDefaultEntry, defaultHistoryContent)
        else:
            if isParallelState(state):
                for child in getChildStates(state):
                    if not statesToEnter.some(lambda s: isDescendant(s,child)):
                        addDescendantStatesToEnter(child,statesToEnter,statesForDefaultEntry, defaultHistoryContent) 

</pre>

<h4 id="addAncestorStatesToEnter"><code>procedure</code> addAncestorStatesToEnter(state, ancestor, statesToEnter, statesForDefaultEntry, defaultHistoryContent)</h4>
<p>Add to statesToEnter any ancestors of 'state' up to, but not including, 'ancestor' that must
	be entered in order to enter 'state'. If any of these ancestor states is a parallel state,
we must fill in its descendants as well.
	</p>
<pre>
procedure addAncestorStatesToEnter(state, ancestor, statesToEnter, statesForDefaultEntry, defaultHistoryContent)
    for anc in getProperAncestors(state,ancestor):
        statesToEnter.add(anc)
        if isParallelState(anc):
            for child in getChildStates(anc):
                if not statesToEnter.some(lambda s: isDescendant(s,child)):
                    addDescendantStatesToEnter(child,statesToEnter,statesForDefaultEntry, defaultHistoryContent) 
</pre>

<h4 id="isInFinalState"><code>procedure</code> isInFinalState(s)</h4>
<p>Return true if s is a compound &lt;state&gt; and one of its children is an active &lt;final&gt; state 
	(i.e. is a member of the current configuration), or if s is a &lt;parallel&gt; state and 
	isInFinalState is true of all its children.</p>
<pre>
function isInFinalState(s):
    if isCompoundState(s):
        return getChildStates(s).some(lambda s: isFinalState(s) and configuration.isMember(s))
    elif isParallelState(s):
        return getChildStates(s).every(isInFinalState)
    else:
        return false
</pre>

<h4 id="getTransitionDomain"><code>function</code> getTransitionDomain(transition)</h4>
<p>Return the compound state such that 1) all states that are exited or entered as a result
	of taking 'transition' are descendants of it 2) no descendant of it has this property.</p>
<pre>
function getTransitionDomain(t)
    tstates = getEffectiveTargetStates(t)
    if not tstates:
        return null
    elif t.type == "internal" and isCompoundState(t.source) and tstates.every(lambda s: isDescendant(s,t.source)):
        return t.source
    else:
        return findLCCA([t.source].append(tstates))

</pre>

<h4 id="findLCCA"><code>function</code> findLCCA(stateList)</h4>
<p>The <a name="LCCA"> Least Common Compound Ancestor </a> is the &lt;state&gt; or &lt;scxml&gt; 
element s such that s is a proper ancestor of all states on 
stateList and no descendant of s has this property. 
Note that there is guaranteed to be such an element since the &lt;scxml&gt; wrapper element 
is a common ancestor of all states. Note also that since we are speaking of proper ancestor 
(parent or parent of a parent, etc.) the LCCA is never a member of stateList.</p>
<pre>
function findLCCA(stateList):
    for anc in getProperAncestors(stateList.head(),null).filter(isCompoundStateOrScxmlElement):
        if stateList.tail().every(lambda s: isDescendant(s,anc)):
            return anc

</pre>
<h4 id="getEffectiveTargetStates"><code>function</code> getEffectiveTargetStates(transition)</h4>
<p>Returns the states that will be the target when 'transition' is taken, dereferencing
	any history states.</p>
<pre>
function getEffectiveTargetStates(transition)
    targets = new OrderedSet()
    for s in transition.target
        if isHistoryState(s):
            if historyValue[s.id]:
                targets.union(historyValue[s.id])
            else:
                targets.union(getEffectiveTargetStates(s.transition))
        else:
            targets.add(s)
    return targets
	</pre>
	
<h4 id="getProperAncestors"><code>function</code> getProperAncestors(state1, state2)</h4>
<p>If state2 is null, returns the set of all ancestors of state1 in ancestry order (state1's parent followed by the parent's parent, etc. up
	to an including the &lt;scxml&gt; element).  
	If state2 is non-null, returns in ancestry order the set of
	all ancestors of state1, up to but not including state2. (A "proper ancestor" of a state
	is its parent, or the parent's parent, or the parent's parent's parent, etc.))If state2 is state1's
	parent, or equal to state1, or a descendant of state1, this returns the empty set.  </p>
	
<h4 id="isDescendant"><code>function</code> isDescendant(state1, state2)</h4>
<p>Returns 'true' if state1 is a descendant of state2 (a child, or a child of a child, or a child of a child of a child, etc.)
Otherwise returns 'false'.</p>

<h4 id="getChildStates"><code>function</code> getChildStates(state1)</h4>
<p>Returns a list containing all &lt;state&gt;, &lt;final&gt;, and &lt;parallel&gt; children
	of state1.</p>
</div1>    
    <div1 id="schemas">
<head>Schema</head>
<p>[This section is informative.]</p> 

<p>Schemas for SCXML can be found in <a href="http://www.w3.org/2011/04/SCXML/">
www.w3.org/2011/04/SCXML</a>.  Two sets of schemas are available.  One uses Schema 1.0 and is relatively
loose, in the sense that it does not enforce all the restrictions contained in this specification.  
Its master schema is <a href="http://www.w3.org/2011/04/SCXML/scxml.xsd">
http://www.w3.org/2011/04/SCXML/scxml.xsd</a>.  The other set of schemas uses Schema 1.1, in particular
the &lt;assert&gt; element, and is stricter.  Its master schema is <a href="http://www.w3.org/2011/04/SCXML/scxml.xsd">
http://www.w3.org/2011/04/SCXML/scxml-strict.xsd</a>.</p>

</div1>
	   <div1 id="relatedWork">
      <head>Related Work </head>
               <p>[This section is  informative.]</p>		
      <p> A number of other XML-based state machine notations have been developed, but none serves the same
      purpose as SCXML.  XMI <bibref ref="XMI"/> is a notation developed for representing UML diagrams, including
      Harel statecharts.  However it is intended as a machine interchange format and is not readily authorable
      by humans.  ebXML <bibref ref="ebXML"/> is a language for business process specification intended to support
      B2B e-commerce applications.  It contains a state machine language that is in some ways similar to the one 
      presented here, but its syntax and semantics are closely tied to its intended use in e-commerce.  It is therefore
      not suitable as a general-purpose state machine language.  XTND <bibref ref="XTND"/>, also called XML
      Transition Network Definition, is a notation for simple finite state machines
      but lacks Harel's notions of hierarchical and parallel states and
      are thus not suitable for a general-purpose state machine that is
      semantically equivalent to Harel state charts.
      </p>

	</div1>
	    <div1 id="Examples">
      <head>Examples</head>
             <p>[This section is  informative.]</p>		

      <div2>
        <head>Language Overview</head>
        <p>This SCXML document gives an overview of the SCXML language 
        and shows the use of its state machine transition
        flows:</p>				
<example>
        <head>Main.scxml</head>
        <eg xml:space="preserve"><xi:include href="SCXMLExamples/Main.scxml" parse="text"/></eg>
</example>
<example>
        <head>Test2Sub1.xml</head>		
        <eg xml:space="preserve"><xi:include href="SCXMLExamples/Test2Sub1.xml" parse="text"/></eg>
</example>
</div2>
<div2>
	<head>Microwave Example</head>
	<p>The example below shows the implementation of a simple microwave oven using SCXML.</p>
	<example>
		<head>microwave-01.scxml</head>
		<eg xml:space="preserve"><xi:include href="SCXMLExamples/microwave-01.scxml" parse="text"/></eg>
</example>
</div2>
<div2 id="MicrowaveParallel">
	<head>Microwave Example (Using parallel)</head>
	<p>The example below shows the implementation of a simple microwave oven using &lt;parallel&gt; and the SCXML In() predicate.</p>
	<example>
		<head>microwave-02.scxml</head>
		<eg xml:space="preserve"><xi:include href="SCXMLExamples/microwave-02.scxml" parse="text"/></eg>
</example>
</div2>
<div2>
	<head>Calculator Example</head>
	<p>The example below shows the implementation of a simple calculator in SCXML.</p>
	<example>
		<head>calc.scxml</head>
		<eg xml:space="preserve"><xi:include href="SCXMLExamples/calc.scxml" parse="text"/></eg>
</example>
</div2>

<div2 id="invokeex">
<head>Examples of Invoke and finalize</head>
<p>The following two SCXML documents demonstrate the use of Invoke and finalize.  The first example
shows the control flow for a voice portal offering traffic reports.  </p>

<example>
        <head>Traffic Report</head>
        <eg xml:space="preserve"><xi:include href="SCXMLExamples/InvokeCanonicalize.scxml" parse="text"/></eg>
</example>
<p> The following example shows a the control flow for a blackjack game.</p>
<example>
        <head>Blackjack</head>
        <eg xml:space="preserve"><xi:include href="SCXMLExamples/blackjack.scxml" parse="text"/></eg>
</example>
        </div2>
        
<div2 id="content_and_namespaces">
	<head>Inline Content and Namespaces</head>
<p>Since SCXML documents are XML documents, normal XML namespace rules
	apply to inline content specified with &lt;content&gt; and &lt;data&gt;.  In particular,
	if no namespace is specified, the inline content will be placed in the SCXML namespace.
	Consider the following example:</p>
<example>
	   <eg space="preserve" xml:space="preserve">	 
 &lt;send target="http://example.com/send/target" type="'http://www.w3.org/TR/scxml/#BasicHTTPEventProcessor'"&gt;
   &lt;content&gt;
     &lt;a&gt;fffff&lt;/a&gt;
   &lt;/content&gt;
  &lt;/send&gt;
  </eg>
  </example>
<p>The recipient of the message will see the following:</p>
<example>
		   <eg space="preserve" xml:space="preserve">	 
 &lt;a xmlns="http://www.w3.org/2005/07/scxml"&gt;fffff&lt;/a&gt;
  </eg>
  </example>
  <p>The following markup would cause the message to be delivered without namespaces:</p>
<example>
	   <eg space="preserve" xml:space="preserve">	 
 &lt;send target="http://example.com/send/target" type="'http://www.w3.org/TR/scxml/#BasicHTTPEventProcessor'"&gt;
   &lt;content&gt;
     &lt;a xmlns=""&gt;fffff&lt;/a&gt;
   &lt;/content&gt;
  &lt;/send&gt;
  </eg>
  </example>
<p>The recipient of the message will see the following:</p>
<example>
		   <eg space="preserve" xml:space="preserve">	 
 &lt;a&gt;fffff&lt;/a&gt;
  </eg>
  </example>
<p>The sender can also specify multiple namespaces:</p>
<example>
	   <eg space="preserve" xml:space="preserve">	 
&lt;send target="http://example.com/send/target" type="'http://www.w3.org/TR/scxml/#BasicHTTPEventProcessor'"&gt;
 &lt;content&gt;
   &lt;root xmlns="http://example.com/r" xmlns:a="http://example.com/a" xmlns:b="http://example.com/b" xmlns:c="http://example.com/c"&gt;
      &lt;a:alpha&gt;1&lt;/a:alpha&gt;
      &lt;b:beta&gt;2&lt;/b:beta&gt;
      &lt;c:gamma&gt;3&lt;/c:gamma&gt;
   &lt;/root&gt;
 &lt;/content&gt;
&lt;/send&gt;
  </eg>
  </example>
<p>In this case, the receiver would  see: </p>
<example>
	   <eg space="preserve" xml:space="preserve">	 
  &lt;root xmlns="http://example.com/r"&gt;
      &lt;alpha xmlns="http://example.com/a"&gt;1&lt;/alpha&gt;
      &lt;beta xmlns="http://example.com/b&gt;2&lt;/beta&gt;
      &lt;gamma xmlns="http://example.com/c&gt;3&lt;/gamma&gt;
  &lt;/root&gt;
  </eg>
  </example>
		
</div2>
        
   <div2 id="custom_action">
    <head>Custom Action Elements</head>  
      <p>
        Custom Action Elements can be defined in other specifications/namespaces and are responsible 
        for performing actions on behalf of custom components. Logically Custom Action Elements can be thought of 
       as a collection of actions and handlers to perform specific tasks. An example of this 
      is a CCXML &lt;accept&gt; element that is a Custom Action Element:</p>
      
      <eg space="preserve" xml:space="preserve">
&lt;transition event="ccxml:connection.alerting"&gt;
  &lt;ccxml:accept connectionid="_event.data.connectionid"/&gt;
&lt;/transition&gt;</eg>
      
      <p>This could be written using a &lt;send&gt; element using the following syntax:</p>
      
      <eg space="preserve" xml:space="preserve">
&lt;datamodel&gt;
&lt;data name="connectionid"/&gt;
&lt;/datamodel&gt;
&lt;transition event="ccxml:connection.alerting"&gt;
  &lt;assign location="connectionid" expr="_event.data.connectionid"/&gt;
 &lt;send type="ccxml" event="ccxml:accept" namelist="connectionid"/&gt; 
&lt;/transition&gt;</eg>

      <p>A more complicated example might be a CCXML &lt;createcall&gt; where you are both 
      providing variables and getting values 
      back that using only the &lt;send&gt; syntax 
      would be more complex as it would need to be 
      broken over several steps. For example:</p>
 <eg space="preserve" xml:space="preserve">
&lt;onentry&gt;
  &lt;ccxml:createcall dest="'tel:+18315552020'" connectionid="myConnectionID"/&gt; 
&lt;/onentry&gt;</eg>
      
      <p>Would need to be modeled in two steps using &lt;send&gt; as you would need to do something like the following:</p>
      
      <eg space="preserve" xml:space="preserve">
&lt;datamodel&gt;
  &lt;data name="dest" expr="'tel:+18315552020'"/&gt;
  &lt;data name="connectionid"/&gt;
&lt;/datamodel&gt;
&lt;onentry&gt;
  &lt;send type="ccxml" event="ccxml:createcall" namelist="dest"/&gt;
&lt;/onentry&gt;
&lt;transition event="ccxml:createcall.success"&gt;
   &lt;assign location="connectionid" expr="_event.data.connectionid"/&gt;
&lt;/transition&gt;</eg>
      
      <p>The exact mappings between Custom Action Elements and &lt;send&gt; actions 
      are to be defined in the individual Custom Action Element specifications. 
      </p>
      </div2>
    </div1>
    
    <div1 id="mimetype">
    	<head>MIME Type</head>
    	         <p>[This section is  normative.]</p>	

<p>This appendix registers a new MIME media type, "<code>application/scxml+xml</code>".</p>

<p>
The "<code>application/scxml+xml</code>" media type is being submitted
to the IESG for review, approval, and registration with IANA.
</p>

<!--
Add the following text according to the actual status.
[[

The "application/scxml+xml" media type is registered with IANA at
<a href="http://www.iana.org/assignments/media-types/application/">http://www.iana.org/assignments/media-types/application/</a>.

]]
-->

<div2 id="media-type-registration">
<head>Registration of MIME media type application/scxml+xml</head>  

<glist>
<label>MIME media type name:</label>
<def><p><code>application</code></p></def>

<label>MIME subtype name:</label>
<def><p><code>scxml+xml</code></p></def>

<label>Required parameters:</label>
<def><p>None</p></def>

<label>Optional parameters:</label>
<def>
  <glist>
  <def><code>charset</code></def>
  <def>
  <p>This parameter has identical semantics to the <code>charset</code> parameter of the 
	<code>application/xml</code> media type as specified in <bibref ref="RFC3023"/> or its successor.</p>
   </def>
   </glist>
</def>

<label>Encoding considerations:</label>
<def>
<p> By virtue of SCXML content being XML, it has the same considerations 
	when sent as "application/scxml+xml"as does XML. See <bibref ref="RFC3023"/> (or its successor), section 3.2.</p>
</def>
	
<label>Security considerations:</label>
<def>
<p>SCXML elements may include arbitrary URIs. 

Therefore, the security issues of <bibref ref="RFC3986"/> section 7
should be considered.

In addition, because of the extensibility features for SCXML, it is
possible that "<code>application/scxml+xml</code>" may describe content that has
security implications beyond those described here.

However, if the processor follows only the normative semantics of this
specification, this content will be ignored.

Only in the case where the processor recognizes and processes the
additional content, or where further processing of that content is
dispatched to other processors, would security issues potentially
arise.

And in that case, they would fall outside the domain of this
registration document.</p>
</def>

<label>Interoperability considerations:</label>
<def>
<p>This specification describes processing semantics that dictate
behavior that must be followed when dealing with, among other
things, unrecognized elements.</p>

<p>Because SCXML is extensible, conformant
"<code>application/scxml+xml</code>" processors MAY expect that
content received is well-formed XML, but processors SHOULD NOT
assume that the content is valid SCXML or expect to recognize all of
the elements and attributes in the document.</p>
</def>

<label>Published specification:</label>
<def>
    <p>This media type registration is extracted from Appendix H of the 
    	<a href="http://www.w3.org/TR/scxml/">
    		State Chart XML (SCXML): State Machine Notation for Control Abstraction</a> specification.
    	</p>
</def>
    	
<label>Additional information:</label>
<def>
   <glist>
   <label>Magic number(s):</label>
   <def>
       <p> There is no single initial octet sequence that is always present in SCXML documents.</p>
   </def>

    <label>File extension(s):</label>
    <def>
        <p>SCXML documents are most often identified with the extensions "<code>.scxml</code>".</p>
    </def>

    <label>Macintosh File Type Code(s):</label>
    <def>
    <p> TEXT</p>
    </def>
    </glist>
</def>

<label>Person and email address to contact for further information:</label>
<def>
   <p> Kazuyuki Ashimura, &lt;<a href=
"mailto:ashimura@w3.org">ashimura@w3.org</a>&gt;.</p>
</def>

<label>Intended usage:</label>
<def>
 <p>   COMMON</p>
</def>

<label>Restrictions on usage:</label>
<def>
 <p>   None</p>
</def>

<label>Author:</label>
<def>
 <p>   The SCXML specification is a work product of the 
 	World Wide Web Consortium's Voice Browser Working Group.</p>
</def>

<label>Change controller:</label>
<def>
<p>The W3C has change control over these specifications.</p>
</def>

</glist>
</div2>


<div2 id="media-type-fragid">
<head>Fragment Identifiers</head>
<p>For documents labeled as "<code>application/scxml+xml</code>", the
fragment identifier notation is exactly that for
"<code>application/xml</code>", as specified in RFC 3023.</p>
</div2>

</div1>
	
	
    <div1 id="references">
      <head>References</head>
      <div2>
      	<head>Normative References</head>
      <blist>

 <bibl id="ECMAScript262" 
   href="http://www.ecma-international.org/publications/standards/Ecma-262.htm"
      key="ECMASCRIPT-262">
      <titleref>ECMAScript Language Specification.  Standard ECMA-262, Edition 5.1
      </titleref> 
      ECMA.  June 2011.
    </bibl>


    <bibl id="E4X" 
   href="http://www.ecma-international.org/publications/standards/Ecma-357.htm"
      key="E4X">
      <titleref>ECMAScript for XML (E4X) Specification
      </titleref> 
      Standard ECMA-357, 2nd Edition, December 2005.
    </bibl>
   
        <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC2119" key="RFC 2119" href="http://www.ietf.org/rfc/rfc2119.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
          <titleref xlink:type="simple" xlink:show="new" 
      xlink:actuate="onRequest">RFC 2119: Key words for use in 
      RFCs to Indicate Requirement Levels</titleref>
          Internet Engineering Task Force. March 1997.
        </bibl>
        <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC2396" key="RFC 2396" href="http://www.ietf.org/rfc/rfc2396.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
          <titleref xlink:type="simple" xlink:show="new" 
      xlink:actuate="onRequest">RFC 2396: Uniform Resource Identifiers</titleref>
          Internet Engineering Task Force. August 1998.
        </bibl>
 
        
           <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="HTTP" key="RFC 2616" href="http://www.ietf.org/rfc/rfc2616.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
          <titleref xlink:type="simple" xlink:show="new" 
      xlink:actuate="onRequest">RFC 2616: Hypertext Transfer Protocol --
       HTTP/1.1</titleref>
          Internet Engineering Task Force. June 1999.
        </bibl>
        
 <bibl id="JSON" href="http://www.ietf.org/rfc/rfc4627.txt"
      key="RFC 4627">
      <titleref>The application/json Media Type for JavaScript Object Notation (JSON)
      </titleref> Internet Engineering Task Force. July 2006.
      </bibl>
      
          <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id ="RFC3023" key="RFC 3023"
        	href ="http://www.ietf.org/rfc/rfc3023.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
        	<titleref xlink:type="simple" xlink:show="new" 
            xlink:actuate="onRequest">RFC 3023: XML Media Types.
      </titleref> Internet Engineering Task Force. January 2001.
      </bibl>
      
 <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id ="RFC3986" key="RFC 3986"
        	href ="http://www.ietf.org/rfc/rfc3986.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
        	<titleref xlink:type="simple" xlink:show="new" 
            xlink:actuate="onRequest">RFC 3986: Uniform Resource Identifier (URI): Generic Syntax.
      </titleref> Internet Engineering Task Force. January 2005.
      </bibl>
      
        
        <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XML" key="XML" href="http://www.w3.org/TR/xml/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
        <titleref xlink:type="simple" xlink:show="new" 
      xlink:actuate="onRequest">Extensible Markup Language (XML) 1.0 
      (Fifth Edition)</titleref>  
      World Wide Web Consortium. W3C Recommendation, November 2008
        </bibl> 
 
        <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLNames" key="XMLNames" href="http://www.w3.org/TR/2006/REC-xml-names-20060816/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
        <titleref xlink:type="simple" xlink:show="new" 
      xlink:actuate="onRequest">Namespaces in XML 1.0 (Second Edition)</titleref>  
      World Wide Web Consortium. W3C Recommendation, August 2006
        </bibl>
       <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="Schema" key="XML Schema" href="http://www.w3.org/TR/xmlschema-2/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
        <titleref xlink:type="simple" xlink:show="new" 
      xlink:actuate="onRequest">XML Schema Part 2: 
      Datatypes Second Edition</titleref> 
      World Wide Web Consortium. W3C Recommendation, October 2004.
        </bibl>

      

      </blist>
      </div2>
      <div2>
      	<head>Informative References</head>
      	<blist>
        <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="ebXML" key="ebXML" href="https://www.oasis-open.org/committees/documents.php?wg_abbrev=ebxml-bp" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
          <titleref xlink:type="simple" xlink:show="new" 
      xlink:actuate="onRequest">ebXML Business Process Specification 
      Schema v2.0</titleref>
        </bibl>     		

      		
      		<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="EL" key="EL" href="http://commons.apache.org/el/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
        <titleref xlink:type="simple" xlink:show="new" 
      xlink:actuate="onRequest">EL: The JSP 2.0 Expression 
      Language Interpreter</titleref>
        </bibl>
        <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="Harel_Politi" key="Harel and Politi" href="http://www.wisdom.weizmann.ac.il/~dharel/reactive_systems.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
        <titleref xlink:type="simple" xlink:show="new" 
      xlink:actuate="onRequest">Modeling Reactive Systems with Statecharts: 
      The STATEMATE Approach</titleref> By D. Harel
        and M. Politi.  McGraw-Hill, 1998.
        </bibl>     
      	       <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="CCXML" key="CCXML 1.0" href="http://www.w3.org/TR/2011/REC-ccxml-20110705/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
          <titleref xlink:type="simple" xlink:show="new" 
      xlink:actuate="onRequest">Voice Browser Call Control: CCXML 
      Version 1.0</titleref>
      World Wide Web Consortium.  W3C Recommendation, July 2011.
        </bibl>
        
                <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="VoiceXML" key="VoiceXML 2.0" href="http://www.w3.org/TR/voicexml20/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
          <titleref xlink:type="simple" xlink:show="new" 
      xlink:actuate="onRequest">VoiceXML 2.0: </titleref>
          World Wide Web Consortium.  W3C Recommendation, March 2004.
        </bibl>
        <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="UML" key="UML 2.3" href="http://www.omg.org/spec/UML/2.3/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
          <titleref xlink:type="simple" xlink:show="new" 
      xlink:actuate="onRequest">UML Specification Version 2.3</titleref>
          OMG, 2009.
        </bibl>  
        
                <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xinclude" key="xinclude" href="http://www.w3.org/TR/xinclude/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
          <titleref xlink:type="simple" xlink:show="new" 
      xlink:actuate="onRequest">XML Inclusions (XInclude) Version 1.0 (Second Editiion)</titleref>
          W3C Recommendation, 2006.
        </bibl>
        
              <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMI" 
              	key="UML XMI" href="http://www.omg.org/spec/XMI/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
          <titleref xlink:type="simple" xlink:show="new" 
      xlink:actuate="onRequest">XML Metadata Exchange version 2.4.1</titleref> OMG. August 2011. 
        </bibl>
           <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XTND" key="XTND" href="http://www.w3.org/TR/2000/NOTE-xtnd-20001121/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
          <titleref xlink:type="simple" xlink:show="new" 
      xlink:actuate="onRequest">XML Transition Network Definition</titleref>
      World Wide Web Consortium.  W3C Note, November 2000.
        </bibl>
      		</blist>
      	</div2>
    </div1>
  </back>

</spec>
